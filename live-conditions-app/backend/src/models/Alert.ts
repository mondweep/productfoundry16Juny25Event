import mongoose, { Document, Schema } from 'mongoose';\nimport { ALERT_TYPES } from '../config/constants';\n\nexport interface IAlert extends Document {\n  _id: mongoose.Types.ObjectId;\n  type: typeof ALERT_TYPES[keyof typeof ALERT_TYPES];\n  title: string;\n  description: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  location: {\n    region: string;\n    latitude: number;\n    longitude: number;\n    radius: number; // in kilometers\n  };\n  conditions: {\n    weather?: {\n      temperature?: { min?: number; max?: number };\n      windSpeed?: { min?: number; max?: number };\n      rainfall?: { min?: number; max?: number };\n      visibility?: { min?: number };\n      uvIndex?: { min?: number };\n    };\n    ocean?: {\n      waveHeight?: { min?: number; max?: number };\n      swellDirection?: string;\n      surfConditions?: string;\n      waterTemperature?: { min?: number; max?: number };\n      tideLevel?: { min?: number; max?: number };\n    };\n    traffic?: {\n      roadClosures?: boolean;\n      delays?: { min?: number }; // minutes\n      congestionLevel?: 'low' | 'medium' | 'high';\n      incidents?: string[];\n    };\n  };\n  isActive: boolean;\n  startTime: Date;\n  endTime?: Date;\n  source: {\n    provider: string;\n    externalId?: string;\n    url?: string;\n  };\n  affectedAreas: string[];\n  priority: number; // 1-10, higher = more urgent\n  notificationsSent: {\n    email: boolean;\n    push: boolean;\n    sms: boolean;\n    webhook: boolean;\n  };\n  metadata: {\n    autoGenerated: boolean;\n    lastUpdated: Date;\n    updateCount: number;\n    relatedAlerts?: mongoose.Types.ObjectId[];\n  };\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nconst alertSchema = new Schema<IAlert>({\n  type: {\n    type: String,\n    enum: Object.values(ALERT_TYPES),\n    required: true,\n    index: true,\n  },\n  title: {\n    type: String,\n    required: true,\n    trim: true,\n    maxlength: 200,\n  },\n  description: {\n    type: String,\n    required: true,\n    trim: true,\n    maxlength: 1000,\n  },\n  severity: {\n    type: String,\n    enum: ['low', 'medium', 'high', 'critical'],\n    required: true,\n    index: true,\n  },\n  location: {\n    region: {\n      type: String,\n      required: true,\n      index: true,\n    },\n    latitude: {\n      type: Number,\n      required: true,\n      min: -90,\n      max: 90,\n    },\n    longitude: {\n      type: Number,\n      required: true,\n      min: -180,\n      max: 180,\n    },\n    radius: {\n      type: Number,\n      required: true,\n      min: 0,\n      max: 1000, // 1000km max radius\n    },\n  },\n  conditions: {\n    weather: {\n      temperature: {\n        min: Number,\n        max: Number,\n      },\n      windSpeed: {\n        min: Number,\n        max: Number,\n      },\n      rainfall: {\n        min: Number,\n        max: Number,\n      },\n      visibility: {\n        min: Number,\n      },\n      uvIndex: {\n        min: Number,\n      },\n    },\n    ocean: {\n      waveHeight: {\n        min: Number,\n        max: Number,\n      },\n      swellDirection: String,\n      surfConditions: String,\n      waterTemperature: {\n        min: Number,\n        max: Number,\n      },\n      tideLevel: {\n        min: Number,\n        max: Number,\n      },\n    },\n    traffic: {\n      roadClosures: Boolean,\n      delays: {\n        min: Number,\n      },\n      congestionLevel: {\n        type: String,\n        enum: ['low', 'medium', 'high'],\n      },\n      incidents: [String],\n    },\n  },\n  isActive: {\n    type: Boolean,\n    default: true,\n    index: true,\n  },\n  startTime: {\n    type: Date,\n    required: true,\n    index: true,\n  },\n  endTime: {\n    type: Date,\n    index: true,\n  },\n  source: {\n    provider: {\n      type: String,\n      required: true,\n    },\n    externalId: String,\n    url: String,\n  },\n  affectedAreas: [{\n    type: String,\n    index: true,\n  }],\n  priority: {\n    type: Number,\n    required: true,\n    min: 1,\n    max: 10,\n    default: 5,\n    index: true,\n  },\n  notificationsSent: {\n    email: { type: Boolean, default: false },\n    push: { type: Boolean, default: false },\n    sms: { type: Boolean, default: false },\n    webhook: { type: Boolean, default: false },\n  },\n  metadata: {\n    autoGenerated: {\n      type: Boolean,\n      default: false,\n    },\n    lastUpdated: {\n      type: Date,\n      default: Date.now,\n    },\n    updateCount: {\n      type: Number,\n      default: 0,\n    },\n    relatedAlerts: [{\n      type: Schema.Types.ObjectId,\n      ref: 'Alert',\n    }],\n  },\n}, {\n  timestamps: true,\n});\n\n// Indexes\nalertSchema.index({ type: 1, severity: 1 });\nalertSchema.index({ 'location.region': 1, isActive: 1 });\nalertSchema.index({ startTime: 1, endTime: 1 });\nalertSchema.index({ priority: -1, createdAt: -1 });\nalertSchema.index({ \n  'location.latitude': 1, \n  'location.longitude': 1 \n});\n\n// Geospatial index for location-based queries\nalertSchema.index({\n  'location.latitude': '2dsphere',\n  'location.longitude': '2dsphere'\n});\n\n// TTL index for expired alerts (cleanup after 30 days)\nalertSchema.index(\n  { endTime: 1 },\n  { \n    expireAfterSeconds: 30 * 24 * 60 * 60, // 30 days\n    partialFilterExpression: { endTime: { $exists: true } }\n  }\n);\n\n// Pre-save middleware\nalertSchema.pre('save', function(next) {\n  if (this.isModified() && !this.isNew) {\n    this.metadata.lastUpdated = new Date();\n    this.metadata.updateCount += 1;\n  }\n  \n  // Ensure endTime is after startTime\n  if (this.endTime && this.endTime <= this.startTime) {\n    return next(new Error('End time must be after start time'));\n  }\n  \n  next();\n});\n\n// Static methods\nalertSchema.statics.findActiveAlerts = function() {\n  return this.find({\n    isActive: true,\n    startTime: { $lte: new Date() },\n    $or: [\n      { endTime: { $exists: false } },\n      { endTime: { $gte: new Date() } }\n    ]\n  });\n};\n\nalertSchema.statics.findByLocation = function(latitude: number, longitude: number, radiusKm: number = 50) {\n  return this.find({\n    isActive: true,\n    $and: [\n      {\n        'location.latitude': {\n          $gte: latitude - (radiusKm / 111), // Rough conversion: 1 degree â‰ˆ 111km\n          $lte: latitude + (radiusKm / 111)\n        }\n      },\n      {\n        'location.longitude': {\n          $gte: longitude - (radiusKm / (111 * Math.cos(latitude * Math.PI / 180))),\n          $lte: longitude + (radiusKm / (111 * Math.cos(latitude * Math.PI / 180)))\n        }\n      }\n    ]\n  }).sort({ priority: -1, createdAt: -1 });\n};\n\nalertSchema.statics.findBySeverity = function(minSeverity: string) {\n  const severityOrder = { low: 1, medium: 2, high: 3, critical: 4 };\n  const minLevel = severityOrder[minSeverity as keyof typeof severityOrder] || 1;\n  \n  const severityFilter = Object.entries(severityOrder)\n    .filter(([, level]) => level >= minLevel)\n    .map(([severity]) => severity);\n  \n  return this.find({\n    isActive: true,\n    severity: { $in: severityFilter }\n  }).sort({ priority: -1, createdAt: -1 });\n};\n\n// Instance methods\nalertSchema.methods.deactivate = async function() {\n  this.isActive = false;\n  this.endTime = new Date();\n  return this.save();\n};\n\nalertSchema.methods.updateNotificationStatus = async function(type: string, sent: boolean) {\n  if (this.notificationsSent.hasOwnProperty(type)) {\n    this.notificationsSent[type as keyof typeof this.notificationsSent] = sent;\n    return this.save();\n  }\n  throw new Error(`Invalid notification type: ${type}`);\n};\n\nexport const Alert = mongoose.model<IAlert>('Alert', alertSchema);\nexport default Alert;"