import mongoose, { Document, Schema } from 'mongoose';\nimport bcrypt from 'bcryptjs';\nimport { USER_ROLES } from '../config/constants';\n\nexport interface IUser extends Document {\n  _id: mongoose.Types.ObjectId;\n  email: string;\n  password: string;\n  firstName: string;\n  lastName: string;\n  role: typeof USER_ROLES[keyof typeof USER_ROLES];\n  isActive: boolean;\n  isEmailVerified: boolean;\n  preferences: {\n    defaultLocation: {\n      latitude: number;\n      longitude: number;\n      address: string;\n      region: string;\n    };\n    units: {\n      temperature: 'celsius' | 'fahrenheit';\n      windSpeed: 'kmh' | 'mph' | 'ms' | 'knots';\n      pressure: 'hPa' | 'inHg' | 'mmHg';\n      distance: 'km' | 'miles';\n    };\n    notifications: {\n      weatherAlerts: boolean;\n      oceanWarnings: boolean;\n      trafficIncidents: boolean;\n      severityThreshold: 'low' | 'medium' | 'high';\n    };\n    dashboard: {\n      defaultView: 'weather' | 'ocean' | 'traffic' | 'combined';\n      autoRefresh: boolean;\n      refreshInterval: number;\n    };\n  };\n  favorites: {\n    locations: Array<{\n      name: string;\n      latitude: number;\n      longitude: number;\n      address: string;\n      type: 'weather' | 'ocean' | 'traffic';\n      createdAt: Date;\n    }>;\n    alerts: Array<{\n      type: string;\n      location: string;\n      conditions: any;\n      createdAt: Date;\n    }>;\n  };\n  subscription: {\n    type: 'free' | 'premium' | 'pro';\n    startDate?: Date;\n    endDate?: Date;\n    stripeCustomerId?: string;\n    stripeSubscriptionId?: string;\n  };\n  loginHistory: Array<{\n    ip: string;\n    userAgent: string;\n    timestamp: Date;\n    success: boolean;\n  }>;\n  refreshTokens: Array<{\n    token: string;\n    createdAt: Date;\n    expiresAt: Date;\n    isActive: boolean;\n  }>;\n  createdAt: Date;\n  updatedAt: Date;\n  lastLoginAt?: Date;\n  \n  // Methods\n  comparePassword(candidatePassword: string): Promise<boolean>;\n  generateAuthTokens(): Promise<{ accessToken: string; refreshToken: string }>;\n  addToLoginHistory(ip: string, userAgent: string, success: boolean): Promise<void>;\n  cleanupExpiredTokens(): Promise<void>;\n}\n\nconst userSchema = new Schema<IUser>({\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n    lowercase: true,\n    trim: true,\n    index: true,\n  },\n  password: {\n    type: String,\n    required: true,\n    minlength: 8,\n  },\n  firstName: {\n    type: String,\n    required: true,\n    trim: true,\n  },\n  lastName: {\n    type: String,\n    required: true,\n    trim: true,\n  },\n  role: {\n    type: String,\n    enum: Object.values(USER_ROLES),\n    default: USER_ROLES.USER,\n  },\n  isActive: {\n    type: Boolean,\n    default: true,\n  },\n  isEmailVerified: {\n    type: Boolean,\n    default: false,\n  },\n  preferences: {\n    defaultLocation: {\n      latitude: { type: Number },\n      longitude: { type: Number },\n      address: { type: String },\n      region: { type: String },\n    },\n    units: {\n      temperature: {\n        type: String,\n        enum: ['celsius', 'fahrenheit'],\n        default: 'celsius',\n      },\n      windSpeed: {\n        type: String,\n        enum: ['kmh', 'mph', 'ms', 'knots'],\n        default: 'kmh',\n      },\n      pressure: {\n        type: String,\n        enum: ['hPa', 'inHg', 'mmHg'],\n        default: 'hPa',\n      },\n      distance: {\n        type: String,\n        enum: ['km', 'miles'],\n        default: 'km',\n      },\n    },\n    notifications: {\n      weatherAlerts: { type: Boolean, default: true },\n      oceanWarnings: { type: Boolean, default: true },\n      trafficIncidents: { type: Boolean, default: false },\n      severityThreshold: {\n        type: String,\n        enum: ['low', 'medium', 'high'],\n        default: 'medium',\n      },\n    },\n    dashboard: {\n      defaultView: {\n        type: String,\n        enum: ['weather', 'ocean', 'traffic', 'combined'],\n        default: 'combined',\n      },\n      autoRefresh: { type: Boolean, default: true },\n      refreshInterval: { type: Number, default: 300000 }, // 5 minutes\n    },\n  },\n  favorites: {\n    locations: [{\n      name: { type: String, required: true },\n      latitude: { type: Number, required: true },\n      longitude: { type: Number, required: true },\n      address: { type: String, required: true },\n      type: {\n        type: String,\n        enum: ['weather', 'ocean', 'traffic'],\n        required: true,\n      },\n      createdAt: { type: Date, default: Date.now },\n    }],\n    alerts: [{\n      type: { type: String, required: true },\n      location: { type: String, required: true },\n      conditions: { type: Schema.Types.Mixed },\n      createdAt: { type: Date, default: Date.now },\n    }],\n  },\n  subscription: {\n    type: {\n      type: String,\n      enum: ['free', 'premium', 'pro'],\n      default: 'free',\n    },\n    startDate: Date,\n    endDate: Date,\n    stripeCustomerId: String,\n    stripeSubscriptionId: String,\n  },\n  loginHistory: [{\n    ip: { type: String, required: true },\n    userAgent: { type: String, required: true },\n    timestamp: { type: Date, default: Date.now },\n    success: { type: Boolean, required: true },\n  }],\n  refreshTokens: [{\n    token: { type: String, required: true },\n    createdAt: { type: Date, default: Date.now },\n    expiresAt: { type: Date, required: true },\n    isActive: { type: Boolean, default: true },\n  }],\n  lastLoginAt: Date,\n}, {\n  timestamps: true,\n  toJSON: {\n    transform: function(doc, ret) {\n      delete ret.password;\n      delete ret.refreshTokens;\n      return ret;\n    }\n  }\n});\n\n// Indexes\nuserSchema.index({ email: 1 });\nuserSchema.index({ role: 1 });\nuserSchema.index({ isActive: 1 });\nuserSchema.index({ 'subscription.type': 1 });\nuserSchema.index({ createdAt: 1 });\n\n// Hash password before saving\nuserSchema.pre('save', async function(next) {\n  if (!this.isModified('password')) return next();\n  \n  try {\n    const salt = await bcrypt.genSalt(parseInt(process.env.BCRYPT_ROUNDS || '12'));\n    this.password = await bcrypt.hash(this.password, salt);\n    next();\n  } catch (error: any) {\n    next(error);\n  }\n});\n\n// Compare password method\nuserSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {\n  return bcrypt.compare(candidatePassword, this.password);\n};\n\n// Generate auth tokens method\nuserSchema.methods.generateAuthTokens = async function(): Promise<{ accessToken: string; refreshToken: string }> {\n  const jwt = require('jsonwebtoken');\n  const { v4: uuidv4 } = require('uuid');\n  \n  // Generate access token\n  const accessToken = jwt.sign(\n    {\n      userId: this._id,\n      email: this.email,\n      role: this.role,\n    },\n    process.env.JWT_SECRET,\n    { expiresIn: process.env.JWT_EXPIRE || '24h' }\n  );\n  \n  // Generate refresh token\n  const refreshToken = jwt.sign(\n    {\n      userId: this._id,\n      tokenId: uuidv4(),\n    },\n    process.env.JWT_REFRESH_SECRET,\n    { expiresIn: process.env.JWT_REFRESH_EXPIRE || '7d' }\n  );\n  \n  // Store refresh token\n  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days\n  this.refreshTokens.push({\n    token: refreshToken,\n    createdAt: new Date(),\n    expiresAt,\n    isActive: true,\n  });\n  \n  await this.save();\n  \n  return { accessToken, refreshToken };\n};\n\n// Add to login history method\nuserSchema.methods.addToLoginHistory = async function(ip: string, userAgent: string, success: boolean): Promise<void> {\n  this.loginHistory.push({\n    ip,\n    userAgent,\n    timestamp: new Date(),\n    success,\n  });\n  \n  // Keep only last 10 login attempts\n  if (this.loginHistory.length > 10) {\n    this.loginHistory = this.loginHistory.slice(-10);\n  }\n  \n  if (success) {\n    this.lastLoginAt = new Date();\n  }\n  \n  await this.save();\n};\n\n// Cleanup expired tokens method\nuserSchema.methods.cleanupExpiredTokens = async function(): Promise<void> {\n  const now = new Date();\n  this.refreshTokens = this.refreshTokens.filter(token => \n    token.isActive && token.expiresAt > now\n  );\n  await this.save();\n};\n\nexport const User = mongoose.model<IUser>('User', userSchema);\nexport default User;"