import { Router } from 'express';\nimport { optionalAuthMiddleware } from '../middleware/auth';\nimport { requirePermission } from '../middleware/apiKey';\nimport { validate, weatherSchemas } from '../middleware/validation';\nimport { catchAsync, AppError } from '../middleware/errorHandler';\nimport { weatherService } from '../services/weather';\nimport { cacheService } from '../services/cache';\nimport { logger } from '../utils/logger';\nimport { HTTP_STATUS_CODES } from '../config/constants';\n\nconst router = Router();\n\n// Apply optional auth to all weather routes\nrouter.use(optionalAuthMiddleware);\n\n// Apply permission check for weather data\nrouter.use(requirePermission('weather:read'));\n\n// Get current weather conditions\nrouter.get('/current',\n  validate(weatherSchemas.getCurrentWeather, 'query'),\n  catchAsync(async (req: any, res) => {\n    const { latitude, longitude, units, include } = req.query;\n    const userId = req.userId;\n    \n    // Generate cache key\n    const cacheKey = `weather:current:${latitude}:${longitude}:${units}:${include.join(',')}`;\n    \n    // Try to get from cache first\n    let weatherData = await cacheService.get(cacheKey, 'weather');\n    \n    if (!weatherData) {\n      logger.info('Weather cache miss, fetching from service:', {\n        latitude,\n        longitude,\n        units,\n        include,\n        userId,\n      });\n      \n      // Fetch from weather service\n      weatherData = await weatherService.getCurrentWeather({\n        latitude: parseFloat(latitude),\n        longitude: parseFloat(longitude),\n        units,\n        include,\n      });\n      \n      // Cache the result\n      await cacheService.set(cacheKey, weatherData, 300, 'weather'); // 5 minutes\n    } else {\n      logger.debug('Weather cache hit:', {\n        latitude,\n        longitude,\n        cacheKey,\n        userId,\n      });\n    }\n    \n    res.json({\n      success: true,\n      data: weatherData,\n      meta: {\n        cached: !!weatherData,\n        location: {\n          latitude: parseFloat(latitude),\n          longitude: parseFloat(longitude),\n        },\n        units,\n        timestamp: new Date().toISOString(),\n      },\n    });\n  })\n);\n\n// Get weather forecast\nrouter.get('/forecast',\n  validate(weatherSchemas.getForecast, 'query'),\n  catchAsync(async (req: any, res) => {\n    const { latitude, longitude, days, units, include } = req.query;\n    const userId = req.userId;\n    \n    // Generate cache key\n    const cacheKey = `weather:forecast:${latitude}:${longitude}:${days}:${units}:${include.join(',')}`;\n    \n    // Try to get from cache first\n    let forecastData = await cacheService.get(cacheKey, 'weatherForecast');\n    \n    if (!forecastData) {\n      logger.info('Weather forecast cache miss, fetching from service:', {\n        latitude,\n        longitude,\n        days,\n        units,\n        include,\n        userId,\n      });\n      \n      // Fetch from weather service\n      forecastData = await weatherService.getForecast({\n        latitude: parseFloat(latitude),\n        longitude: parseFloat(longitude),\n        days: parseInt(days),\n        units,\n        include,\n      });\n      \n      // Cache the result for longer (30 minutes)\n      await cacheService.set(cacheKey, forecastData, 1800, 'weatherForecast');\n    } else {\n      logger.debug('Weather forecast cache hit:', {\n        latitude,\n        longitude,\n        cacheKey,\n        userId,\n      });\n    }\n    \n    res.json({\n      success: true,\n      data: forecastData,\n      meta: {\n        cached: !!forecastData,\n        location: {\n          latitude: parseFloat(latitude),\n          longitude: parseFloat(longitude),\n        },\n        days: parseInt(days),\n        units,\n        timestamp: new Date().toISOString(),\n      },\n    });\n  })\n);\n\n// Get historical weather data\nrouter.get('/historical',\n  validate(weatherSchemas.getHistoricalWeather, 'query'),\n  catchAsync(async (req: any, res) => {\n    const { latitude, longitude, startDate, endDate, units } = req.query;\n    const userId = req.userId;\n    \n    // Generate cache key\n    const cacheKey = `weather:historical:${latitude}:${longitude}:${startDate}:${endDate}:${units}`;\n    \n    // Try to get from cache first\n    let historicalData = await cacheService.get(cacheKey, 'weatherForecast');\n    \n    if (!historicalData) {\n      logger.info('Historical weather cache miss, fetching from service:', {\n        latitude,\n        longitude,\n        startDate,\n        endDate,\n        units,\n        userId,\n      });\n      \n      // Fetch from weather service\n      historicalData = await weatherService.getHistoricalWeather({\n        latitude: parseFloat(latitude),\n        longitude: parseFloat(longitude),\n        startDate: new Date(startDate),\n        endDate: new Date(endDate),\n        units,\n      });\n      \n      // Cache historical data for longer (1 hour)\n      await cacheService.set(cacheKey, historicalData, 3600, 'weatherForecast');\n    } else {\n      logger.debug('Historical weather cache hit:', {\n        latitude,\n        longitude,\n        cacheKey,\n        userId,\n      });\n    }\n    \n    res.json({\n      success: true,\n      data: historicalData,\n      meta: {\n        cached: !!historicalData,\n        location: {\n          latitude: parseFloat(latitude),\n          longitude: parseFloat(longitude),\n        },\n        period: {\n          startDate,\n          endDate,\n        },\n        units,\n        timestamp: new Date().toISOString(),\n      },\n    });\n  })\n);\n\n// Get weather alerts for location\nrouter.get('/alerts',\n  validate(weatherSchemas.getCurrentWeather, 'query'),\n  catchAsync(async (req: any, res) => {\n    const { latitude, longitude } = req.query;\n    const userId = req.userId;\n    \n    // Generate cache key\n    const cacheKey = `weather:alerts:${latitude}:${longitude}`;\n    \n    // Try to get from cache first\n    let alertsData = await cacheService.get(cacheKey, 'alerts');\n    \n    if (!alertsData) {\n      logger.info('Weather alerts cache miss, fetching from service:', {\n        latitude,\n        longitude,\n        userId,\n      });\n      \n      // Fetch from weather service\n      alertsData = await weatherService.getWeatherAlerts({\n        latitude: parseFloat(latitude),\n        longitude: parseFloat(longitude),\n      });\n      \n      // Cache alerts for short time (2 minutes)\n      await cacheService.set(cacheKey, alertsData, 120, 'alerts');\n    } else {\n      logger.debug('Weather alerts cache hit:', {\n        latitude,\n        longitude,\n        cacheKey,\n        userId,\n      });\n    }\n    \n    res.json({\n      success: true,\n      data: alertsData,\n      meta: {\n        cached: !!alertsData,\n        location: {\n          latitude: parseFloat(latitude),\n          longitude: parseFloat(longitude),\n        },\n        timestamp: new Date().toISOString(),\n      },\n    });\n  })\n);\n\n// Get weather stations near location\nrouter.get('/stations',\n  validate(weatherSchemas.getCurrentWeather, 'query'),\n  catchAsync(async (req: any, res) => {\n    const { latitude, longitude } = req.query;\n    const radius = req.query.radius || 50; // km\n    const userId = req.userId;\n    \n    // Generate cache key\n    const cacheKey = `weather:stations:${latitude}:${longitude}:${radius}`;\n    \n    // Try to get from cache first\n    let stationsData = await cacheService.get(cacheKey, 'weather');\n    \n    if (!stationsData) {\n      logger.info('Weather stations cache miss, fetching from service:', {\n        latitude,\n        longitude,\n        radius,\n        userId,\n      });\n      \n      // Fetch from weather service\n      stationsData = await weatherService.getNearbyStations({\n        latitude: parseFloat(latitude),\n        longitude: parseFloat(longitude),\n        radius: parseFloat(radius),\n      });\n      \n      // Cache stations data for longer (1 hour)\n      await cacheService.set(cacheKey, stationsData, 3600, 'weather');\n    } else {\n      logger.debug('Weather stations cache hit:', {\n        latitude,\n        longitude,\n        cacheKey,\n        userId,\n      });\n    }\n    \n    res.json({\n      success: true,\n      data: stationsData,\n      meta: {\n        cached: !!stationsData,\n        location: {\n          latitude: parseFloat(latitude),\n          longitude: parseFloat(longitude),\n        },\n        radius: parseFloat(radius),\n        timestamp: new Date().toISOString(),\n      },\n    });\n  })\n);\n\n// Get radar/satellite imagery\nrouter.get('/radar',\n  validate(weatherSchemas.getCurrentWeather, 'query'),\n  catchAsync(async (req: any, res) => {\n    const { latitude, longitude } = req.query;\n    const type = req.query.type || 'radar'; // radar, satellite\n    const zoom = req.query.zoom || 6;\n    const userId = req.userId;\n    \n    // Generate cache key\n    const cacheKey = `weather:${type}:${latitude}:${longitude}:${zoom}`;\n    \n    // Try to get from cache first\n    let imageData = await cacheService.get(cacheKey, 'weather');\n    \n    if (!imageData) {\n      logger.info('Weather imagery cache miss, fetching from service:', {\n        latitude,\n        longitude,\n        type,\n        zoom,\n        userId,\n      });\n      \n      // Fetch from weather service\n      imageData = await weatherService.getWeatherImagery({\n        latitude: parseFloat(latitude),\n        longitude: parseFloat(longitude),\n        type,\n        zoom: parseInt(zoom),\n      });\n      \n      // Cache imagery for medium time (10 minutes)\n      await cacheService.set(cacheKey, imageData, 600, 'weather');\n    } else {\n      logger.debug('Weather imagery cache hit:', {\n        latitude,\n        longitude,\n        cacheKey,\n        userId,\n      });\n    }\n    \n    res.json({\n      success: true,\n      data: imageData,\n      meta: {\n        cached: !!imageData,\n        location: {\n          latitude: parseFloat(latitude),\n          longitude: parseFloat(longitude),\n        },\n        type,\n        zoom: parseInt(zoom),\n        timestamp: new Date().toISOString(),\n      },\n    });\n  })\n);\n\n// Search weather by location name\nrouter.get('/search',\n  catchAsync(async (req: any, res) => {\n    const { q: query, limit = 10 } = req.query;\n    const userId = req.userId;\n    \n    if (!query || query.trim().length < 2) {\n      throw new AppError('Search query must be at least 2 characters', HTTP_STATUS_CODES.BAD_REQUEST);\n    }\n    \n    // Generate cache key\n    const cacheKey = `weather:search:${query.toLowerCase()}:${limit}`;\n    \n    // Try to get from cache first\n    let searchResults = await cacheService.get(cacheKey, 'weather');\n    \n    if (!searchResults) {\n      logger.info('Weather search cache miss, fetching from service:', {\n        query,\n        limit,\n        userId,\n      });\n      \n      // Fetch from weather service\n      searchResults = await weatherService.searchLocations({\n        query: query.trim(),\n        limit: parseInt(limit),\n      });\n      \n      // Cache search results for longer (30 minutes)\n      await cacheService.set(cacheKey, searchResults, 1800, 'weather');\n    } else {\n      logger.debug('Weather search cache hit:', {\n        query,\n        cacheKey,\n        userId,\n      });\n    }\n    \n    res.json({\n      success: true,\n      data: searchResults,\n      meta: {\n        cached: !!searchResults,\n        query,\n        limit: parseInt(limit),\n        timestamp: new Date().toISOString(),\n      },\n    });\n  })\n);\n\nexport default router;"