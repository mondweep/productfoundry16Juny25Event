import { Router } from 'express';\nimport { optionalAuthMiddleware, authMiddleware } from '../middleware/auth';\nimport { requirePermission } from '../middleware/apiKey';\nimport { validate, alertSchemas } from '../middleware/validation';\nimport { catchAsync, AppError, createNotFoundError } from '../middleware/errorHandler';\nimport { Alert } from '../models/Alert';\nimport { cacheService } from '../services/cache';\nimport { logger } from '../utils/logger';\nimport { HTTP_STATUS_CODES } from '../config/constants';\nimport { broadcast } from '../services/websocket';\n\nconst router = Router();\n\n// Apply optional auth to read routes\nrouter.use(optionalAuthMiddleware);\n\n// Get alerts for location\nrouter.get('/',\n  requirePermission('alerts:read'),\n  validate(alertSchemas.getAlerts, 'query'),\n  catchAsync(async (req: any, res) => {\n    const {\n      latitude,\n      longitude,\n      radius,\n      type,\n      severity,\n      isActive,\n      page,\n      limit,\n      sort,\n    } = req.query;\n    const userId = req.userId;\n    \n    // Build query\n    const query: any = {};\n    \n    if (isActive !== undefined) {\n      query.isActive = isActive;\n    }\n    \n    if (type) {\n      query.type = type;\n    }\n    \n    if (severity) {\n      query.severity = severity;\n    }\n    \n    // Location-based filtering\n    if (latitude && longitude) {\n      const alerts = await Alert.findByLocation(\n        parseFloat(latitude),\n        parseFloat(longitude),\n        parseFloat(radius)\n      );\n      \n      res.json({\n        success: true,\n        data: {\n          alerts,\n          total: alerts.length,\n          page: 1,\n          limit: alerts.length,\n        },\n        meta: {\n          location: {\n            latitude: parseFloat(latitude),\n            longitude: parseFloat(longitude),\n            radius: parseFloat(radius),\n          },\n          filters: { type, severity, isActive },\n          timestamp: new Date().toISOString(),\n        },\n      });\n      return;\n    }\n    \n    // General alert query with pagination\n    const skip = (page - 1) * limit;\n    \n    const [alerts, total] = await Promise.all([\n      Alert.find(query)\n        .sort(sort)\n        .skip(skip)\n        .limit(limit)\n        .lean(),\n      Alert.countDocuments(query),\n    ]);\n    \n    logger.info('Alerts fetched:', {\n      query,\n      total,\n      page,\n      limit,\n      userId,\n    });\n    \n    res.json({\n      success: true,\n      data: {\n        alerts,\n        total,\n        page,\n        limit,\n        pages: Math.ceil(total / limit),\n      },\n      meta: {\n        filters: { type, severity, isActive },\n        timestamp: new Date().toISOString(),\n      },\n    });\n  })\n);\n\n// Get active alerts\nrouter.get('/active',\n  requirePermission('alerts:read'),\n  catchAsync(async (req: any, res) => {\n    const userId = req.userId;\n    \n    // Try cache first\n    const cacheKey = 'alerts:active';\n    let activeAlerts = await cacheService.get(cacheKey, 'alerts');\n    \n    if (!activeAlerts) {\n      activeAlerts = await Alert.findActiveAlerts();\n      await cacheService.set(cacheKey, activeAlerts, 120, 'alerts'); // 2 minutes\n    }\n    \n    logger.info('Active alerts fetched:', {\n      count: activeAlerts.length,\n      userId,\n    });\n    \n    res.json({\n      success: true,\n      data: {\n        alerts: activeAlerts,\n        total: activeAlerts.length,\n      },\n      meta: {\n        cached: !!activeAlerts,\n        timestamp: new Date().toISOString(),\n      },\n    });\n  })\n);\n\n// Get alert by ID\nrouter.get('/:id',\n  requirePermission('alerts:read'),\n  catchAsync(async (req, res) => {\n    const { id } = req.params;\n    \n    const alert = await Alert.findById(id);\n    if (!alert) {\n      throw createNotFoundError('Alert');\n    }\n    \n    res.json({\n      success: true,\n      data: { alert },\n    });\n  })\n);\n\n// Protected routes (require authentication)\nrouter.use(authMiddleware);\n\n// Create new alert (admin only)\nrouter.post('/',\n  requirePermission('alerts:write'),\n  validate(alertSchemas.createAlert),\n  catchAsync(async (req: any, res) => {\n    const alertData = req.body;\n    const userId = req.userId;\n    \n    // Add metadata\n    alertData.metadata = {\n      autoGenerated: false,\n      lastUpdated: new Date(),\n      updateCount: 0,\n    };\n    \n    const alert = new Alert(alertData);\n    await alert.save();\n    \n    // Broadcast to WebSocket subscribers\n    broadcast('alerts', {\n      type: 'new_alert',\n      alert,\n    });\n    \n    // Clear cache\n    await cacheService.del('alerts:active', 'alerts');\n    \n    logger.info('Alert created:', {\n      alertId: alert._id,\n      type: alert.type,\n      severity: alert.severity,\n      userId,\n    });\n    \n    res.status(HTTP_STATUS_CODES.CREATED).json({\n      success: true,\n      message: 'Alert created successfully',\n      data: { alert },\n    });\n  })\n);\n\n// Update alert\nrouter.put('/:id',\n  requirePermission('alerts:write'),\n  validate(alertSchemas.updateAlert),\n  catchAsync(async (req, res) => {\n    const { id } = req.params;\n    const updates = req.body;\n    const userId = (req as any).userId;\n    \n    const alert = await Alert.findById(id);\n    if (!alert) {\n      throw createNotFoundError('Alert');\n    }\n    \n    // Update fields\n    Object.assign(alert, updates);\n    await alert.save();\n    \n    // Broadcast update\n    broadcast('alerts', {\n      type: 'alert_updated',\n      alert,\n    });\n    \n    // Clear cache\n    await cacheService.del('alerts:active', 'alerts');\n    \n    logger.info('Alert updated:', {\n      alertId: alert._id,\n      updates: Object.keys(updates),\n      userId,\n    });\n    \n    res.json({\n      success: true,\n      message: 'Alert updated successfully',\n      data: { alert },\n    });\n  })\n);\n\n// Deactivate alert\nrouter.delete('/:id',\n  requirePermission('alerts:write'),\n  catchAsync(async (req, res) => {\n    const { id } = req.params;\n    const userId = (req as any).userId;\n    \n    const alert = await Alert.findById(id);\n    if (!alert) {\n      throw createNotFoundError('Alert');\n    }\n    \n    await alert.deactivate();\n    \n    // Broadcast deactivation\n    broadcast('alerts', {\n      type: 'alert_deactivated',\n      alertId: alert._id,\n    });\n    \n    // Clear cache\n    await cacheService.del('alerts:active', 'alerts');\n    \n    logger.info('Alert deactivated:', {\n      alertId: alert._id,\n      userId,\n    });\n    \n    res.json({\n      success: true,\n      message: 'Alert deactivated successfully',\n    });\n  })\n);\n\n// Update notification status\nrouter.patch('/:id/notifications',\n  requirePermission('alerts:write'),\n  catchAsync(async (req, res) => {\n    const { id } = req.params;\n    const { type, sent } = req.body;\n    const userId = (req as any).userId;\n    \n    if (!type || typeof sent !== 'boolean') {\n      throw new AppError(\n        'Notification type and sent status are required',\n        HTTP_STATUS_CODES.BAD_REQUEST\n      );\n    }\n    \n    const alert = await Alert.findById(id);\n    if (!alert) {\n      throw createNotFoundError('Alert');\n    }\n    \n    await alert.updateNotificationStatus(type, sent);\n    \n    logger.info('Alert notification status updated:', {\n      alertId: alert._id,\n      type,\n      sent,\n      userId,\n    });\n    \n    res.json({\n      success: true,\n      message: 'Notification status updated successfully',\n      data: {\n        notificationsSent: alert.notificationsSent,\n      },\n    });\n  })\n);\n\nexport default router;"