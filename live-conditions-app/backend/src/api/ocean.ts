import { Router } from 'express';\nimport { optionalAuthMiddleware } from '../middleware/auth';\nimport { requirePermission } from '../middleware/apiKey';\nimport { validate, oceanSchemas } from '../middleware/validation';\nimport { catchAsync } from '../middleware/errorHandler';\nimport { cacheService } from '../services/cache';\nimport { logger } from '../utils/logger';\n\nconst router = Router();\n\n// Apply optional auth to all ocean routes\nrouter.use(optionalAuthMiddleware);\n\n// Apply permission check for ocean data\nrouter.use(requirePermission('ocean:read'));\n\n// Get current ocean conditions\nrouter.get('/conditions',\n  validate(oceanSchemas.getOceanConditions, 'query'),\n  catchAsync(async (req: any, res) => {\n    const { latitude, longitude, include } = req.query;\n    const userId = req.userId;\n    \n    // Generate cache key\n    const cacheKey = `ocean:conditions:${latitude}:${longitude}:${include.join(',')}`;\n    \n    // Mock ocean conditions data\n    const oceanData = {\n      location: {\n        latitude: parseFloat(latitude),\n        longitude: parseFloat(longitude),\n      },\n      waves: {\n        significantHeight: 1.2,\n        maxHeight: 2.1,\n        period: 8.5,\n        direction: 225,\n        swellHeight: 0.8,\n        swellPeriod: 12.0,\n        swellDirection: 210,\n      },\n      tides: {\n        current: {\n          height: 0.3,\n          type: 'rising',\n          nextHigh: '2024-01-15T14:30:00Z',\n          nextLow: '2024-01-15T08:15:00Z',\n        },\n        today: [\n          { time: '2024-01-15T02:15:00Z', height: 3.2, type: 'high' },\n          { time: '2024-01-15T08:15:00Z', height: 0.1, type: 'low' },\n          { time: '2024-01-15T14:30:00Z', height: 3.4, type: 'high' },\n          { time: '2024-01-15T20:45:00Z', height: 0.3, type: 'low' },\n        ],\n      },\n      waterTemperature: 18.5,\n      salinity: 35.2,\n      visibility: 15,\n      currents: {\n        speed: 0.3,\n        direction: 180,\n        surface: 0.3,\n        subsurface: 0.2,\n      },\n      lastUpdated: new Date().toISOString(),\n    };\n    \n    logger.info('Ocean conditions requested:', {\n      latitude,\n      longitude,\n      include,\n      userId,\n    });\n    \n    res.json({\n      success: true,\n      data: oceanData,\n      meta: {\n        location: {\n          latitude: parseFloat(latitude),\n          longitude: parseFloat(longitude),\n        },\n        timestamp: new Date().toISOString(),\n      },\n    });\n  })\n);\n\n// Get surf forecast\nrouter.get('/surf',\n  validate(oceanSchemas.getSurfForecast, 'query'),\n  catchAsync(async (req: any, res) => {\n    const { latitude, longitude, days, spots } = req.query;\n    const userId = req.userId;\n    \n    // Mock surf forecast data\n    const surfData = {\n      location: {\n        latitude: parseFloat(latitude),\n        longitude: parseFloat(longitude),\n      },\n      forecast: Array.from({ length: days }, (_, i) => ({\n        date: new Date(Date.now() + i * 24 * 60 * 60 * 1000).toISOString().split('T')[0],\n        surf: {\n          min: 0.5 + Math.random() * 1.5,\n          max: 1.5 + Math.random() * 2.0,\n          rating: Math.floor(Math.random() * 5) + 1,\n          conditions: ['Clean', 'Choppy', 'Messy'][Math.floor(Math.random() * 3)],\n        },\n        wind: {\n          speed: 5 + Math.random() * 15,\n          direction: Math.floor(Math.random() * 360),\n          effect: ['Offshore', 'Onshore', 'Cross'][Math.floor(Math.random() * 3)],\n        },\n        tide: {\n          high: '14:30',\n          low: '08:15',\n          height: 0.5 + Math.random() * 3,\n        },\n      })),\n      spots: spots || [],\n    };\n    \n    logger.info('Surf forecast requested:', {\n      latitude,\n      longitude,\n      days,\n      spots,\n      userId,\n    });\n    \n    res.json({\n      success: true,\n      data: surfData,\n      meta: {\n        location: {\n          latitude: parseFloat(latitude),\n          longitude: parseFloat(longitude),\n        },\n        days,\n        timestamp: new Date().toISOString(),\n      },\n    });\n  })\n);\n\n// Get tide data\nrouter.get('/tides',\n  validate(oceanSchemas.getTideData, 'query'),\n  catchAsync(async (req: any, res) => {\n    const { latitude, longitude, date, days } = req.query;\n    const userId = req.userId;\n    \n    const startDate = new Date(date);\n    \n    // Mock tide data\n    const tideData = {\n      location: {\n        latitude: parseFloat(latitude),\n        longitude: parseFloat(longitude),\n      },\n      tides: Array.from({ length: days }, (_, dayIndex) => {\n        const currentDate = new Date(startDate.getTime() + dayIndex * 24 * 60 * 60 * 1000);\n        return {\n          date: currentDate.toISOString().split('T')[0],\n          events: [\n            {\n              time: '02:15',\n              height: 3.2 + Math.random() * 0.5,\n              type: 'high',\n            },\n            {\n              time: '08:15',\n              height: 0.1 + Math.random() * 0.3,\n              type: 'low',\n            },\n            {\n              time: '14:30',\n              height: 3.4 + Math.random() * 0.5,\n              type: 'high',\n            },\n            {\n              time: '20:45',\n              height: 0.3 + Math.random() * 0.3,\n              type: 'low',\n            },\n          ],\n        };\n      }),\n    };\n    \n    logger.info('Tide data requested:', {\n      latitude,\n      longitude,\n      date,\n      days,\n      userId,\n    });\n    \n    res.json({\n      success: true,\n      data: tideData,\n      meta: {\n        location: {\n          latitude: parseFloat(latitude),\n          longitude: parseFloat(longitude),\n        },\n        period: {\n          startDate: startDate.toISOString().split('T')[0],\n          days,\n        },\n        timestamp: new Date().toISOString(),\n      },\n    });\n  })\n);\n\nexport default router;"