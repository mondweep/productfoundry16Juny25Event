import { Router } from 'express';\nimport { checkDatabaseHealth } from '../config/database';\nimport { cacheService } from '../services/cache';\nimport { getConnectionStats } from '../services/websocket';\nimport { logger } from '../utils/logger';\nimport { HTTP_STATUS_CODES } from '../config/constants';\nimport os from 'os';\n\nconst router = Router();\nconst startTime = Date.now();\n\n// Basic health check\nrouter.get('/', async (req, res) => {\n  try {\n    const uptime = Date.now() - startTime;\n    const memoryUsage = process.memoryUsage();\n    \n    // Basic health status\n    const health = {\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      uptime: {\n        process: uptime,\n        system: os.uptime() * 1000, // Convert to milliseconds\n      },\n      memory: {\n        used: Math.round(memoryUsage.heapUsed / 1024 / 1024), // MB\n        total: Math.round(memoryUsage.heapTotal / 1024 / 1024), // MB\n        external: Math.round(memoryUsage.external / 1024 / 1024), // MB\n        rss: Math.round(memoryUsage.rss / 1024 / 1024), // MB\n      },\n      system: {\n        platform: os.platform(),\n        arch: os.arch(),\n        nodeVersion: process.version,\n        cpus: os.cpus().length,\n        loadAvg: os.loadavg(),\n        freeMemory: Math.round(os.freemem() / 1024 / 1024), // MB\n        totalMemory: Math.round(os.totalmem() / 1024 / 1024), // MB\n      },\n      environment: {\n        nodeEnv: process.env.NODE_ENV || 'development',\n        apiVersion: process.env.API_VERSION || 'v1',\n      },\n    };\n    \n    res.json({\n      success: true,\n      data: health,\n    });\n  } catch (error: any) {\n    logger.error('Health check error:', error);\n    \n    res.status(HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR).json({\n      success: false,\n      status: 'unhealthy',\n      error: error.message,\n      timestamp: new Date().toISOString(),\n    });\n  }\n});\n\n// Detailed health check\nrouter.get('/detailed', async (req, res) => {\n  try {\n    const uptime = Date.now() - startTime;\n    const memoryUsage = process.memoryUsage();\n    \n    // Check database health\n    const dbHealth = await checkDatabaseHealth();\n    \n    // Check cache health\n    const cacheHealth = await cacheService.healthCheck();\n    \n    // Get WebSocket stats\n    const wsStats = getConnectionStats();\n    \n    // Calculate health status\n    const isHealthy = (\n      dbHealth.status === 'healthy' &&\n      cacheHealth.status === 'healthy' &&\n      memoryUsage.heapUsed < memoryUsage.heapTotal * 0.9 // Less than 90% memory usage\n    );\n    \n    const health = {\n      status: isHealthy ? 'healthy' : 'degraded',\n      timestamp: new Date().toISOString(),\n      uptime: {\n        process: uptime,\n        system: os.uptime() * 1000,\n        formatted: {\n          process: formatUptime(uptime),\n          system: formatUptime(os.uptime() * 1000),\n        },\n      },\n      memory: {\n        used: Math.round(memoryUsage.heapUsed / 1024 / 1024),\n        total: Math.round(memoryUsage.heapTotal / 1024 / 1024),\n        external: Math.round(memoryUsage.external / 1024 / 1024),\n        rss: Math.round(memoryUsage.rss / 1024 / 1024),\n        usage: Math.round((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100),\n      },\n      system: {\n        platform: os.platform(),\n        arch: os.arch(),\n        nodeVersion: process.version,\n        cpus: os.cpus().length,\n        loadAvg: os.loadavg().map(avg => Math.round(avg * 100) / 100),\n        freeMemory: Math.round(os.freemem() / 1024 / 1024),\n        totalMemory: Math.round(os.totalmem() / 1024 / 1024),\n        memoryUsage: Math.round(((os.totalmem() - os.freemem()) / os.totalmem()) * 100),\n      },\n      services: {\n        database: dbHealth,\n        cache: cacheHealth,\n        websocket: {\n          status: 'healthy',\n          details: wsStats,\n        },\n      },\n      environment: {\n        nodeEnv: process.env.NODE_ENV || 'development',\n        apiVersion: process.env.API_VERSION || 'v1',\n        port: process.env.PORT || 3001,\n        wsPort: process.env.WS_PORT || 3002,\n      },\n    };\n    \n    const statusCode = isHealthy ? HTTP_STATUS_CODES.OK : HTTP_STATUS_CODES.SERVICE_UNAVAILABLE;\n    \n    res.status(statusCode).json({\n      success: isHealthy,\n      data: health,\n    });\n  } catch (error: any) {\n    logger.error('Detailed health check error:', error);\n    \n    res.status(HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR).json({\n      success: false,\n      status: 'unhealthy',\n      error: error.message,\n      timestamp: new Date().toISOString(),\n    });\n  }\n});\n\n// Readiness check (for Kubernetes)\nrouter.get('/ready', async (req, res) => {\n  try {\n    // Check if all critical services are ready\n    const dbHealth = await checkDatabaseHealth();\n    const cacheHealth = await cacheService.healthCheck();\n    \n    const isReady = (\n      dbHealth.status === 'healthy' &&\n      cacheHealth.status === 'healthy'\n    );\n    \n    if (isReady) {\n      res.json({\n        success: true,\n        status: 'ready',\n        timestamp: new Date().toISOString(),\n      });\n    } else {\n      res.status(HTTP_STATUS_CODES.SERVICE_UNAVAILABLE).json({\n        success: false,\n        status: 'not ready',\n        timestamp: new Date().toISOString(),\n        checks: {\n          database: dbHealth.status,\n          cache: cacheHealth.status,\n        },\n      });\n    }\n  } catch (error: any) {\n    logger.error('Readiness check error:', error);\n    \n    res.status(HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR).json({\n      success: false,\n      status: 'not ready',\n      error: error.message,\n      timestamp: new Date().toISOString(),\n    });\n  }\n});\n\n// Liveness check (for Kubernetes)\nrouter.get('/live', (req, res) => {\n  // Simple check that the process is alive\n  res.json({\n    success: true,\n    status: 'alive',\n    timestamp: new Date().toISOString(),\n    uptime: Date.now() - startTime,\n  });\n});\n\n// Database health check\nrouter.get('/db', async (req, res) => {\n  try {\n    const dbHealth = await checkDatabaseHealth();\n    \n    const statusCode = dbHealth.status === 'healthy' \n      ? HTTP_STATUS_CODES.OK \n      : HTTP_STATUS_CODES.SERVICE_UNAVAILABLE;\n    \n    res.status(statusCode).json({\n      success: dbHealth.status === 'healthy',\n      data: dbHealth,\n      timestamp: new Date().toISOString(),\n    });\n  } catch (error: any) {\n    logger.error('Database health check error:', error);\n    \n    res.status(HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR).json({\n      success: false,\n      status: 'unhealthy',\n      error: error.message,\n      timestamp: new Date().toISOString(),\n    });\n  }\n});\n\n// Cache health check\nrouter.get('/cache', async (req, res) => {\n  try {\n    const cacheHealth = await cacheService.healthCheck();\n    \n    const statusCode = cacheHealth.status === 'healthy' \n      ? HTTP_STATUS_CODES.OK \n      : HTTP_STATUS_CODES.SERVICE_UNAVAILABLE;\n    \n    res.status(statusCode).json({\n      success: cacheHealth.status === 'healthy',\n      data: cacheHealth,\n      timestamp: new Date().toISOString(),\n    });\n  } catch (error: any) {\n    logger.error('Cache health check error:', error);\n    \n    res.status(HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR).json({\n      success: false,\n      status: 'unhealthy',\n      error: error.message,\n      timestamp: new Date().toISOString(),\n    });\n  }\n});\n\n// WebSocket health check\nrouter.get('/websocket', (req, res) => {\n  try {\n    const wsStats = getConnectionStats();\n    \n    res.json({\n      success: true,\n      status: 'healthy',\n      data: wsStats,\n      timestamp: new Date().toISOString(),\n    });\n  } catch (error: any) {\n    logger.error('WebSocket health check error:', error);\n    \n    res.status(HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR).json({\n      success: false,\n      status: 'unhealthy',\n      error: error.message,\n      timestamp: new Date().toISOString(),\n    });\n  }\n});\n\n// System metrics\nrouter.get('/metrics', async (req, res) => {\n  try {\n    const uptime = Date.now() - startTime;\n    const memoryUsage = process.memoryUsage();\n    const cacheStats = await cacheService.getStats();\n    const wsStats = getConnectionStats();\n    \n    const metrics = {\n      timestamp: new Date().toISOString(),\n      uptime,\n      memory: {\n        heapUsed: memoryUsage.heapUsed,\n        heapTotal: memoryUsage.heapTotal,\n        external: memoryUsage.external,\n        rss: memoryUsage.rss,\n        arrayBuffers: memoryUsage.arrayBuffers,\n      },\n      system: {\n        loadAvg: os.loadavg(),\n        freeMemory: os.freemem(),\n        totalMemory: os.totalmem(),\n        cpus: os.cpus().length,\n        platform: os.platform(),\n        arch: os.arch(),\n      },\n      cache: cacheStats,\n      websocket: wsStats,\n      process: {\n        pid: process.pid,\n        version: process.version,\n        versions: process.versions,\n        title: process.title,\n      },\n    };\n    \n    res.json({\n      success: true,\n      data: metrics,\n    });\n  } catch (error: any) {\n    logger.error('Metrics collection error:', error);\n    \n    res.status(HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR).json({\n      success: false,\n      error: error.message,\n      timestamp: new Date().toISOString(),\n    });\n  }\n});\n\n// Format uptime to human readable format\nconst formatUptime = (ms: number): string => {\n  const seconds = Math.floor(ms / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n  const days = Math.floor(hours / 24);\n  \n  if (days > 0) {\n    return `${days}d ${hours % 24}h ${minutes % 60}m ${seconds % 60}s`;\n  } else if (hours > 0) {\n    return `${hours}h ${minutes % 60}m ${seconds % 60}s`;\n  } else if (minutes > 0) {\n    return `${minutes}m ${seconds % 60}s`;\n  } else {\n    return `${seconds}s`;\n  }\n};\n\nexport default router;"