import NodeCache from 'node-cache';\nimport { logger } from '../utils/logger';\nimport { CACHE_KEYS, CACHE_TTL } from '../config/constants';\n\n// Cache configuration\ninterface CacheConfig {\n  stdTTL: number; // Standard TTL in seconds\n  checkperiod: number; // Check period for expired keys\n  useClones: boolean; // Clone cached objects\n  deleteOnExpire: boolean; // Delete expired keys automatically\n  enableLegacyCallbacks: boolean; // Enable legacy callbacks\n  maxKeys: number; // Maximum number of keys\n}\n\nconst defaultConfig: CacheConfig = {\n  stdTTL: CACHE_TTL.WEATHER_CURRENT,\n  checkperiod: 120, // Check every 2 minutes\n  useClones: false,\n  deleteOnExpire: true,\n  enableLegacyCallbacks: false,\n  maxKeys: 10000,\n};\n\n// Initialize cache instances\nconst caches = {\n  // General purpose cache\n  general: new NodeCache({\n    ...defaultConfig,\n    stdTTL: CACHE_TTL.WEATHER_CURRENT,\n  }),\n  \n  // Weather data cache\n  weather: new NodeCache({\n    ...defaultConfig,\n    stdTTL: CACHE_TTL.WEATHER_CURRENT,\n    maxKeys: 5000,\n  }),\n  \n  // Weather forecast cache (longer TTL)\n  weatherForecast: new NodeCache({\n    ...defaultConfig,\n    stdTTL: CACHE_TTL.WEATHER_FORECAST,\n    maxKeys: 2000,\n  }),\n  \n  // Ocean conditions cache\n  ocean: new NodeCache({\n    ...defaultConfig,\n    stdTTL: CACHE_TTL.OCEAN_CONDITIONS,\n    maxKeys: 3000,\n  }),\n  \n  // Traffic conditions cache (short TTL)\n  traffic: new NodeCache({\n    ...defaultConfig,\n    stdTTL: CACHE_TTL.TRAFFIC_CONDITIONS,\n    maxKeys: 5000,\n  }),\n  \n  // Alerts cache (very short TTL)\n  alerts: new NodeCache({\n    ...defaultConfig,\n    stdTTL: CACHE_TTL.ALERTS,\n    maxKeys: 1000,\n  }),\n  \n  // User data cache\n  users: new NodeCache({\n    ...defaultConfig,\n    stdTTL: CACHE_TTL.USER_DATA,\n    maxKeys: 10000,\n  }),\n  \n  // API response cache for external services\n  apiResponses: new NodeCache({\n    ...defaultConfig,\n    stdTTL: 300, // 5 minutes\n    maxKeys: 1000,\n  }),\n  \n  // Session cache\n  sessions: new NodeCache({\n    ...defaultConfig,\n    stdTTL: 3600, // 1 hour\n    maxKeys: 5000,\n  }),\n};\n\n// Cache service class\nclass CacheService {\n  private getCache(cacheType: string): NodeCache {\n    return (caches as any)[cacheType] || caches.general;\n  }\n\n  // Set cache value\n  async set(\n    key: string,\n    value: any,\n    ttl?: number,\n    cacheType: string = 'general'\n  ): Promise<boolean> {\n    try {\n      const cache = this.getCache(cacheType);\n      const result = cache.set(key, value, ttl);\n      \n      logger.debug('Cache set:', {\n        key,\n        cacheType,\n        ttl: ttl || cache.options.stdTTL,\n        success: result,\n      });\n      \n      return result;\n    } catch (error: any) {\n      logger.error('Cache set error:', {\n        key,\n        cacheType,\n        error: error.message,\n      });\n      return false;\n    }\n  }\n\n  // Get cache value\n  async get<T = any>(key: string, cacheType: string = 'general'): Promise<T | undefined> {\n    try {\n      const cache = this.getCache(cacheType);\n      const value = cache.get<T>(key);\n      \n      logger.debug('Cache get:', {\n        key,\n        cacheType,\n        hit: value !== undefined,\n      });\n      \n      return value;\n    } catch (error: any) {\n      logger.error('Cache get error:', {\n        key,\n        cacheType,\n        error: error.message,\n      });\n      return undefined;\n    }\n  }\n\n  // Delete cache value\n  async del(key: string, cacheType: string = 'general'): Promise<number> {\n    try {\n      const cache = this.getCache(cacheType);\n      const result = cache.del(key);\n      \n      logger.debug('Cache delete:', {\n        key,\n        cacheType,\n        deleted: result,\n      });\n      \n      return result;\n    } catch (error: any) {\n      logger.error('Cache delete error:', {\n        key,\n        cacheType,\n        error: error.message,\n      });\n      return 0;\n    }\n  }\n\n  // Check if key exists\n  async has(key: string, cacheType: string = 'general'): Promise<boolean> {\n    try {\n      const cache = this.getCache(cacheType);\n      return cache.has(key);\n    } catch (error: any) {\n      logger.error('Cache has error:', {\n        key,\n        cacheType,\n        error: error.message,\n      });\n      return false;\n    }\n  }\n\n  // Get multiple values\n  async mget<T = any>(keys: string[], cacheType: string = 'general'): Promise<{ [key: string]: T }> {\n    try {\n      const cache = this.getCache(cacheType);\n      const result = cache.mget<T>(keys);\n      \n      logger.debug('Cache mget:', {\n        keys,\n        cacheType,\n        hits: Object.keys(result).length,\n        total: keys.length,\n      });\n      \n      return result;\n    } catch (error: any) {\n      logger.error('Cache mget error:', {\n        keys,\n        cacheType,\n        error: error.message,\n      });\n      return {};\n    }\n  }\n\n  // Set multiple values\n  async mset(keyValuePairs: Array<{ key: string; val: any; ttl?: number }>, cacheType: string = 'general'): Promise<boolean> {\n    try {\n      const cache = this.getCache(cacheType);\n      const result = cache.mset(keyValuePairs);\n      \n      logger.debug('Cache mset:', {\n        count: keyValuePairs.length,\n        cacheType,\n        success: result,\n      });\n      \n      return result;\n    } catch (error: any) {\n      logger.error('Cache mset error:', {\n        count: keyValuePairs.length,\n        cacheType,\n        error: error.message,\n      });\n      return false;\n    }\n  }\n\n  // Get cache statistics\n  async getStats(cacheType?: string): Promise<any> {\n    try {\n      if (cacheType) {\n        const cache = this.getCache(cacheType);\n        return {\n          [cacheType]: cache.getStats(),\n        };\n      }\n      \n      // Get stats for all caches\n      const stats: any = {};\n      for (const [type, cache] of Object.entries(caches)) {\n        stats[type] = cache.getStats();\n      }\n      \n      return stats;\n    } catch (error: any) {\n      logger.error('Cache stats error:', {\n        cacheType,\n        error: error.message,\n      });\n      return {};\n    }\n  }\n\n  // Clear cache\n  async clear(cacheType?: string): Promise<void> {\n    try {\n      if (cacheType) {\n        const cache = this.getCache(cacheType);\n        cache.flushAll();\n        logger.info('Cache cleared:', { cacheType });\n      } else {\n        // Clear all caches\n        for (const [type, cache] of Object.entries(caches)) {\n          cache.flushAll();\n        }\n        logger.info('All caches cleared');\n      }\n    } catch (error: any) {\n      logger.error('Cache clear error:', {\n        cacheType,\n        error: error.message,\n      });\n    }\n  }\n\n  // Get cache keys\n  async getKeys(cacheType: string = 'general'): Promise<string[]> {\n    try {\n      const cache = this.getCache(cacheType);\n      return cache.keys();\n    } catch (error: any) {\n      logger.error('Cache getKeys error:', {\n        cacheType,\n        error: error.message,\n      });\n      return [];\n    }\n  }\n\n  // Set TTL for existing key\n  async ttl(key: string, ttl: number, cacheType: string = 'general'): Promise<boolean> {\n    try {\n      const cache = this.getCache(cacheType);\n      const result = cache.ttl(key, ttl);\n      \n      logger.debug('Cache TTL set:', {\n        key,\n        ttl,\n        cacheType,\n        success: result,\n      });\n      \n      return result;\n    } catch (error: any) {\n      logger.error('Cache TTL error:', {\n        key,\n        ttl,\n        cacheType,\n        error: error.message,\n      });\n      return false;\n    }\n  }\n\n  // Get TTL for key\n  async getTtl(key: string, cacheType: string = 'general'): Promise<number | undefined> {\n    try {\n      const cache = this.getCache(cacheType);\n      return cache.getTtl(key);\n    } catch (error: any) {\n      logger.error('Cache getTtl error:', {\n        key,\n        cacheType,\n        error: error.message,\n      });\n      return undefined;\n    }\n  }\n\n  // Cache wrapper for functions\n  async wrap<T>(\n    key: string,\n    fn: () => Promise<T>,\n    ttl?: number,\n    cacheType: string = 'general'\n  ): Promise<T> {\n    try {\n      // Try to get from cache first\n      const cached = await this.get<T>(key, cacheType);\n      if (cached !== undefined) {\n        logger.debug('Cache hit for wrapped function:', { key, cacheType });\n        return cached;\n      }\n      \n      // Execute function and cache result\n      logger.debug('Cache miss for wrapped function, executing:', { key, cacheType });\n      const result = await fn();\n      \n      // Only cache if result is not null/undefined\n      if (result !== null && result !== undefined) {\n        await this.set(key, result, ttl, cacheType);\n      }\n      \n      return result;\n    } catch (error: any) {\n      logger.error('Cache wrap error:', {\n        key,\n        cacheType,\n        error: error.message,\n      });\n      \n      // If cache fails, still try to execute the function\n      return await fn();\n    }\n  }\n\n  // Increment a numeric value\n  async incr(key: string, amount: number = 1, cacheType: string = 'general'): Promise<number | undefined> {\n    try {\n      const cache = this.getCache(cacheType);\n      const current = cache.get<number>(key) || 0;\n      const newValue = current + amount;\n      \n      cache.set(key, newValue);\n      \n      logger.debug('Cache increment:', {\n        key,\n        amount,\n        previous: current,\n        new: newValue,\n        cacheType,\n      });\n      \n      return newValue;\n    } catch (error: any) {\n      logger.error('Cache increment error:', {\n        key,\n        amount,\n        cacheType,\n        error: error.message,\n      });\n      return undefined;\n    }\n  }\n\n  // Generate cache key with prefix\n  generateKey(prefix: string, ...parts: (string | number)[]): string {\n    return [prefix, ...parts].join(':');\n  }\n\n  // Health check\n  async healthCheck(): Promise<{ status: string; details: any }> {\n    try {\n      const stats = await this.getStats();\n      const totalKeys = Object.values(stats).reduce((sum: number, cache: any) => sum + cache.keys, 0);\n      \n      return {\n        status: 'healthy',\n        details: {\n          totalCaches: Object.keys(caches).length,\n          totalKeys,\n          cacheStats: stats,\n        },\n      };\n    } catch (error: any) {\n      return {\n        status: 'unhealthy',\n        details: {\n          error: error.message,\n        },\n      };\n    }\n  }\n}\n\n// Create and export cache service instance\nexport const cacheService = new CacheService();\n\n// Setup cache event listeners\nObject.entries(caches).forEach(([type, cache]) => {\n  cache.on('set', (key, value) => {\n    logger.debug(`Cache ${type} set:`, { key });\n  });\n  \n  cache.on('del', (key, value) => {\n    logger.debug(`Cache ${type} delete:`, { key });\n  });\n  \n  cache.on('expired', (key, value) => {\n    logger.debug(`Cache ${type} expired:`, { key });\n  });\n  \n  cache.on('flush', () => {\n    logger.info(`Cache ${type} flushed`);\n  });\n});\n\nlogger.info('Cache service initialized with types:', Object.keys(caches));\n\nexport default cacheService;"