import { WebSocketServer, WebSocket } from 'ws';\nimport jwt from 'jsonwebtoken';\nimport { logger } from '../utils/logger';\nimport { WEBSOCKET_EVENTS } from '../config/constants';\nimport { User, IUser } from '../models/User';\nimport { cacheService } from './cache';\n\n// WebSocket client interface\ninterface WebSocketClient extends WebSocket {\n  id: string;\n  user?: IUser;\n  isAuthenticated: boolean;\n  subscriptions: Set<string>;\n  lastHeartbeat: number;\n  metadata: {\n    userAgent?: string;\n    ip?: string;\n    connectTime: number;\n  };\n}\n\n// WebSocket message interface\ninterface WebSocketMessage {\n  type: string;\n  data?: any;\n  requestId?: string;\n  timestamp: number;\n}\n\n// WebSocket response interface\ninterface WebSocketResponse {\n  type: string;\n  data?: any;\n  requestId?: string;\n  success: boolean;\n  error?: string;\n  timestamp: number;\n}\n\n// Active connections store\nconst connections = new Map<string, WebSocketClient>();\nconst userConnections = new Map<string, Set<string>>(); // userId -> Set of connection IDs\nconst subscriptions = new Map<string, Set<string>>(); // subscription topic -> Set of connection IDs\n\n// WebSocket server setup\nexport const setupWebSocket = (wss: WebSocketServer): void => {\n  logger.info('Setting up WebSocket server');\n\n  wss.on('connection', (ws: WebSocket, request) => {\n    const client = ws as WebSocketClient;\n    client.id = generateConnectionId();\n    client.isAuthenticated = false;\n    client.subscriptions = new Set();\n    client.lastHeartbeat = Date.now();\n    client.metadata = {\n      userAgent: request.headers['user-agent'],\n      ip: request.socket.remoteAddress,\n      connectTime: Date.now(),\n    };\n\n    connections.set(client.id, client);\n\n    logger.info('WebSocket client connected:', {\n      connectionId: client.id,\n      ip: client.metadata.ip,\n      userAgent: client.metadata.userAgent,\n      totalConnections: connections.size,\n    });\n\n    // Send welcome message\n    sendMessage(client, {\n      type: 'connection',\n      data: {\n        connectionId: client.id,\n        message: 'Connected to Live Conditions WebSocket',\n        serverTime: new Date().toISOString(),\n      },\n      success: true,\n      timestamp: Date.now(),\n    });\n\n    // Handle incoming messages\n    client.on('message', (data: Buffer) => {\n      handleMessage(client, data);\n    });\n\n    // Handle client disconnect\n    client.on('close', (code: number, reason: Buffer) => {\n      handleDisconnect(client, code, reason.toString());\n    });\n\n    // Handle errors\n    client.on('error', (error: Error) => {\n      logger.error('WebSocket error:', {\n        connectionId: client.id,\n        error: error.message,\n        userId: client.user?._id,\n      });\n    });\n\n    // Handle pong (heartbeat response)\n    client.on('pong', () => {\n      client.lastHeartbeat = Date.now();\n    });\n  });\n\n  // Setup heartbeat interval\n  const heartbeatInterval = parseInt(process.env.WS_HEARTBEAT_INTERVAL || '30000');\n  setInterval(() => {\n    checkHeartbeats();\n  }, heartbeatInterval);\n\n  logger.info('WebSocket server setup complete');\n};\n\n// Generate unique connection ID\nconst generateConnectionId = (): string => {\n  return `ws_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n};\n\n// Handle incoming messages\nconst handleMessage = async (client: WebSocketClient, data: Buffer): Promise<void> => {\n  try {\n    const message: WebSocketMessage = JSON.parse(data.toString());\n    \n    logger.debug('WebSocket message received:', {\n      connectionId: client.id,\n      type: message.type,\n      userId: client.user?._id,\n    });\n\n    switch (message.type) {\n      case 'authenticate':\n        await handleAuthentication(client, message);\n        break;\n      \n      case 'subscribe':\n        await handleSubscription(client, message);\n        break;\n      \n      case 'unsubscribe':\n        await handleUnsubscription(client, message);\n        break;\n      \n      case 'heartbeat':\n        handleHeartbeat(client, message);\n        break;\n      \n      case 'location_update':\n        await handleLocationUpdate(client, message);\n        break;\n      \n      case 'get_data':\n        await handleDataRequest(client, message);\n        break;\n      \n      default:\n        sendErrorResponse(client, message.requestId, `Unknown message type: ${message.type}`);\n    }\n  } catch (error: any) {\n    logger.error('Error handling WebSocket message:', {\n      connectionId: client.id,\n      error: error.message,\n      data: data.toString(),\n    });\n    \n    sendErrorResponse(client, undefined, 'Invalid message format');\n  }\n};\n\n// Handle authentication\nconst handleAuthentication = async (client: WebSocketClient, message: WebSocketMessage): Promise<void> => {\n  try {\n    const { token } = message.data;\n    \n    if (!token) {\n      sendErrorResponse(client, message.requestId, 'Authentication token required');\n      return;\n    }\n\n    // Verify JWT token\n    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;\n    const user = await User.findById(decoded.userId).select('-password -refreshTokens');\n    \n    if (!user || !user.isActive) {\n      sendErrorResponse(client, message.requestId, 'Invalid or inactive user');\n      return;\n    }\n\n    client.user = user;\n    client.isAuthenticated = true;\n\n    // Track user connections\n    const userId = user._id.toString();\n    if (!userConnections.has(userId)) {\n      userConnections.set(userId, new Set());\n    }\n    userConnections.get(userId)!.add(client.id);\n\n    logger.info('WebSocket client authenticated:', {\n      connectionId: client.id,\n      userId: user._id,\n      email: user.email,\n    });\n\n    sendMessage(client, {\n      type: 'authenticated',\n      data: {\n        user: {\n          id: user._id,\n          email: user.email,\n          firstName: user.firstName,\n          lastName: user.lastName,\n        },\n      },\n      requestId: message.requestId,\n      success: true,\n      timestamp: Date.now(),\n    });\n  } catch (error: any) {\n    logger.error('Authentication error:', {\n      connectionId: client.id,\n      error: error.message,\n    });\n    \n    sendErrorResponse(client, message.requestId, 'Authentication failed');\n  }\n};\n\n// Handle subscription to data streams\nconst handleSubscription = async (client: WebSocketClient, message: WebSocketMessage): Promise<void> => {\n  try {\n    const { topics } = message.data;\n    \n    if (!Array.isArray(topics)) {\n      sendErrorResponse(client, message.requestId, 'Topics must be an array');\n      return;\n    }\n\n    const validTopics = ['weather', 'ocean', 'traffic', 'alerts', 'user_specific'];\n    const invalidTopics = topics.filter((topic: string) => !validTopics.includes(topic));\n    \n    if (invalidTopics.length > 0) {\n      sendErrorResponse(client, message.requestId, `Invalid topics: ${invalidTopics.join(', ')}`);\n      return;\n    }\n\n    // Add subscriptions\n    topics.forEach((topic: string) => {\n      client.subscriptions.add(topic);\n      \n      if (!subscriptions.has(topic)) {\n        subscriptions.set(topic, new Set());\n      }\n      subscriptions.get(topic)!.add(client.id);\n    });\n\n    logger.info('Client subscribed to topics:', {\n      connectionId: client.id,\n      userId: client.user?._id,\n      topics,\n      totalSubscriptions: client.subscriptions.size,\n    });\n\n    sendMessage(client, {\n      type: 'subscribed',\n      data: {\n        topics,\n        totalSubscriptions: client.subscriptions.size,\n      },\n      requestId: message.requestId,\n      success: true,\n      timestamp: Date.now(),\n    });\n  } catch (error: any) {\n    logger.error('Subscription error:', {\n      connectionId: client.id,\n      error: error.message,\n    });\n    \n    sendErrorResponse(client, message.requestId, 'Subscription failed');\n  }\n};\n\n// Handle unsubscription\nconst handleUnsubscription = async (client: WebSocketClient, message: WebSocketMessage): Promise<void> => {\n  try {\n    const { topics } = message.data;\n    \n    if (!Array.isArray(topics)) {\n      sendErrorResponse(client, message.requestId, 'Topics must be an array');\n      return;\n    }\n\n    // Remove subscriptions\n    topics.forEach((topic: string) => {\n      client.subscriptions.delete(topic);\n      \n      if (subscriptions.has(topic)) {\n        subscriptions.get(topic)!.delete(client.id);\n        \n        // Clean up empty subscription sets\n        if (subscriptions.get(topic)!.size === 0) {\n          subscriptions.delete(topic);\n        }\n      }\n    });\n\n    logger.info('Client unsubscribed from topics:', {\n      connectionId: client.id,\n      userId: client.user?._id,\n      topics,\n      remainingSubscriptions: client.subscriptions.size,\n    });\n\n    sendMessage(client, {\n      type: 'unsubscribed',\n      data: {\n        topics,\n        remainingSubscriptions: client.subscriptions.size,\n      },\n      requestId: message.requestId,\n      success: true,\n      timestamp: Date.now(),\n    });\n  } catch (error: any) {\n    logger.error('Unsubscription error:', {\n      connectionId: client.id,\n      error: error.message,\n    });\n    \n    sendErrorResponse(client, message.requestId, 'Unsubscription failed');\n  }\n};\n\n// Handle heartbeat\nconst handleHeartbeat = (client: WebSocketClient, message: WebSocketMessage): void => {\n  client.lastHeartbeat = Date.now();\n  \n  sendMessage(client, {\n    type: 'heartbeat',\n    data: {\n      serverTime: new Date().toISOString(),\n      connectionId: client.id,\n    },\n    requestId: message.requestId,\n    success: true,\n    timestamp: Date.now(),\n  });\n};\n\n// Handle location updates\nconst handleLocationUpdate = async (client: WebSocketClient, message: WebSocketMessage): Promise<void> => {\n  if (!client.isAuthenticated) {\n    sendErrorResponse(client, message.requestId, 'Authentication required');\n    return;\n  }\n\n  try {\n    const { latitude, longitude } = message.data;\n    \n    if (typeof latitude !== 'number' || typeof longitude !== 'number') {\n      sendErrorResponse(client, message.requestId, 'Invalid coordinates');\n      return;\n    }\n\n    // Store user location in cache for real-time updates\n    await cacheService.set(\n      `user_location:${client.user!._id}`,\n      { latitude, longitude, timestamp: Date.now() },\n      300 // 5 minutes TTL\n    );\n\n    logger.info('User location updated:', {\n      connectionId: client.id,\n      userId: client.user!._id,\n      latitude,\n      longitude,\n    });\n\n    sendMessage(client, {\n      type: 'location_updated',\n      data: {\n        latitude,\n        longitude,\n        timestamp: Date.now(),\n      },\n      requestId: message.requestId,\n      success: true,\n      timestamp: Date.now(),\n    });\n  } catch (error: any) {\n    logger.error('Location update error:', {\n      connectionId: client.id,\n      error: error.message,\n    });\n    \n    sendErrorResponse(client, message.requestId, 'Location update failed');\n  }\n};\n\n// Handle data requests\nconst handleDataRequest = async (client: WebSocketClient, message: WebSocketMessage): Promise<void> => {\n  try {\n    const { type, ...params } = message.data;\n    \n    let data;\n    switch (type) {\n      case 'weather':\n        data = await getWeatherData(params);\n        break;\n      case 'ocean':\n        data = await getOceanData(params);\n        break;\n      case 'traffic':\n        data = await getTrafficData(params);\n        break;\n      case 'alerts':\n        data = await getAlertsData(params);\n        break;\n      default:\n        sendErrorResponse(client, message.requestId, `Unknown data type: ${type}`);\n        return;\n    }\n\n    sendMessage(client, {\n      type: 'data_response',\n      data: {\n        type,\n        ...data,\n      },\n      requestId: message.requestId,\n      success: true,\n      timestamp: Date.now(),\n    });\n  } catch (error: any) {\n    logger.error('Data request error:', {\n      connectionId: client.id,\n      error: error.message,\n    });\n    \n    sendErrorResponse(client, message.requestId, 'Data request failed');\n  }\n};\n\n// Handle client disconnect\nconst handleDisconnect = (client: WebSocketClient, code: number, reason: string): void => {\n  logger.info('WebSocket client disconnected:', {\n    connectionId: client.id,\n    userId: client.user?._id,\n    code,\n    reason,\n    duration: Date.now() - client.metadata.connectTime,\n  });\n\n  // Remove from connections\n  connections.delete(client.id);\n\n  // Remove from user connections\n  if (client.user) {\n    const userId = client.user._id.toString();\n    const userConns = userConnections.get(userId);\n    if (userConns) {\n      userConns.delete(client.id);\n      if (userConns.size === 0) {\n        userConnections.delete(userId);\n      }\n    }\n  }\n\n  // Remove from subscriptions\n  client.subscriptions.forEach(topic => {\n    const topicSubs = subscriptions.get(topic);\n    if (topicSubs) {\n      topicSubs.delete(client.id);\n      if (topicSubs.size === 0) {\n        subscriptions.delete(topic);\n      }\n    }\n  });\n};\n\n// Send message to client\nconst sendMessage = (client: WebSocketClient, message: WebSocketResponse): void => {\n  if (client.readyState === WebSocket.OPEN) {\n    try {\n      client.send(JSON.stringify(message));\n    } catch (error: any) {\n      logger.error('Error sending WebSocket message:', {\n        connectionId: client.id,\n        error: error.message,\n      });\n    }\n  }\n};\n\n// Send error response\nconst sendErrorResponse = (client: WebSocketClient, requestId?: string, error: string = 'Unknown error'): void => {\n  sendMessage(client, {\n    type: 'error',\n    error,\n    requestId,\n    success: false,\n    timestamp: Date.now(),\n  });\n};\n\n// Broadcast to subscribers\nexport const broadcast = (topic: string, data: any): void => {\n  const topicSubs = subscriptions.get(topic);\n  if (!topicSubs || topicSubs.size === 0) {\n    return;\n  }\n\n  const message: WebSocketResponse = {\n    type: 'broadcast',\n    data: {\n      topic,\n      ...data,\n    },\n    success: true,\n    timestamp: Date.now(),\n  };\n\n  let successCount = 0;\n  let errorCount = 0;\n\n  topicSubs.forEach(connectionId => {\n    const client = connections.get(connectionId);\n    if (client) {\n      try {\n        sendMessage(client, message);\n        successCount++;\n      } catch (error) {\n        errorCount++;\n      }\n    }\n  });\n\n  logger.debug('Broadcast sent:', {\n    topic,\n    totalSubscribers: topicSubs.size,\n    successCount,\n    errorCount,\n  });\n};\n\n// Send to specific user\nexport const sendToUser = (userId: string, data: any): void => {\n  const userConns = userConnections.get(userId);\n  if (!userConns || userConns.size === 0) {\n    return;\n  }\n\n  const message: WebSocketResponse = {\n    type: 'user_message',\n    data,\n    success: true,\n    timestamp: Date.now(),\n  };\n\n  userConns.forEach(connectionId => {\n    const client = connections.get(connectionId);\n    if (client) {\n      sendMessage(client, message);\n    }\n  });\n};\n\n// Check heartbeats and clean up dead connections\nconst checkHeartbeats = (): void => {\n  const now = Date.now();\n  const timeout = 60000; // 1 minute timeout\n  const deadConnections: string[] = [];\n\n  connections.forEach((client, connectionId) => {\n    if (now - client.lastHeartbeat > timeout) {\n      deadConnections.push(connectionId);\n    } else {\n      // Send ping to check if connection is alive\n      if (client.readyState === WebSocket.OPEN) {\n        client.ping();\n      }\n    }\n  });\n\n  // Clean up dead connections\n  deadConnections.forEach(connectionId => {\n    const client = connections.get(connectionId);\n    if (client) {\n      logger.warn('Cleaning up dead WebSocket connection:', {\n        connectionId,\n        userId: client.user?._id,\n        lastHeartbeat: new Date(client.lastHeartbeat).toISOString(),\n      });\n      \n      client.terminate();\n      handleDisconnect(client, 1006, 'Heartbeat timeout');\n    }\n  });\n};\n\n// Get connection statistics\nexport const getConnectionStats = () => {\n  return {\n    totalConnections: connections.size,\n    authenticatedConnections: Array.from(connections.values()).filter(c => c.isAuthenticated).length,\n    uniqueUsers: userConnections.size,\n    subscriptions: {\n      totalTopics: subscriptions.size,\n      topicStats: Object.fromEntries(\n        Array.from(subscriptions.entries()).map(([topic, subs]) => [topic, subs.size])\n      ),\n    },\n  };\n};\n\n// Placeholder functions for data retrieval (to be implemented with actual services)\nconst getWeatherData = async (params: any) => {\n  // This would integrate with weather service\n  return { weather: 'data', params };\n};\n\nconst getOceanData = async (params: any) => {\n  // This would integrate with ocean service\n  return { ocean: 'data', params };\n};\n\nconst getTrafficData = async (params: any) => {\n  // This would integrate with traffic service\n  return { traffic: 'data', params };\n};\n\nconst getAlertsData = async (params: any) => {\n  // This would integrate with alerts service\n  return { alerts: 'data', params };\n};\n\nexport default {\n  setupWebSocket,\n  broadcast,\n  sendToUser,\n  getConnectionStats,\n};"