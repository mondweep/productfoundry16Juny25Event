import { Request, Response, NextFunction } from 'express';\nimport { RateLimiterMemory, RateLimiterRedis } from 'rate-limiter-flexible';\nimport { logger } from '../utils/logger';\nimport { HTTP_STATUS_CODES } from '../config/constants';\n\n// Rate limiter configuration\nconst WINDOW_SIZE_IN_MINUTES = parseInt(process.env.RATE_LIMIT_WINDOW || '15');\nconst MAX_REQUESTS = parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || '100');\n\n// Redis connection (optional)\nconst redisUrl = process.env.REDIS_URL;\nlet rateLimiter: RateLimiterMemory | RateLimiterRedis;\n\nif (redisUrl) {\n  // Use Redis for distributed rate limiting\n  const Redis = require('ioredis');\n  const redisClient = new Redis(redisUrl);\n  \n  rateLimiter = new RateLimiterRedis({\n    storeClient: redisClient,\n    keyPrefix: 'rl:general',\n    points: MAX_REQUESTS, // Number of requests\n    duration: WINDOW_SIZE_IN_MINUTES * 60, // Per X seconds\n    blockDuration: WINDOW_SIZE_IN_MINUTES * 60, // Block for X seconds if limit exceeded\n  });\n  \n  logger.info('Rate limiter using Redis store');\n} else {\n  // Use in-memory rate limiting\n  rateLimiter = new RateLimiterMemory({\n    keyPrefix: 'rl:general',\n    points: MAX_REQUESTS,\n    duration: WINDOW_SIZE_IN_MINUTES * 60,\n    blockDuration: WINDOW_SIZE_IN_MINUTES * 60,\n  });\n  \n  logger.info('Rate limiter using memory store');\n}\n\n// Strict rate limiter for authentication endpoints\nconst authRateLimiter = new RateLimiterMemory({\n  keyPrefix: 'rl:auth',\n  points: 5, // 5 requests\n  duration: 15 * 60, // Per 15 minutes\n  blockDuration: 15 * 60, // Block for 15 minutes\n});\n\n// API rate limiter for external API calls\nconst apiRateLimiter = new RateLimiterMemory({\n  keyPrefix: 'rl:api',\n  points: 1000, // 1000 requests\n  duration: 60, // Per minute\n  blockDuration: 60, // Block for 1 minute\n});\n\n// Premium user rate limiter (higher limits)\nconst premiumRateLimiter = new RateLimiterMemory({\n  keyPrefix: 'rl:premium',\n  points: MAX_REQUESTS * 5, // 5x the normal limit\n  duration: WINDOW_SIZE_IN_MINUTES * 60,\n  blockDuration: WINDOW_SIZE_IN_MINUTES * 60,\n});\n\n// Get client identifier (IP + User ID if available)\nconst getClientId = (req: Request): string => {\n  const userId = (req as any).userId;\n  const ip = req.ip || req.connection.remoteAddress || 'unknown';\n  return userId ? `user:${userId}` : `ip:${ip}`;\n};\n\n// Get user subscription type\nconst getUserSubscription = (req: Request): string => {\n  const user = (req as any).user;\n  return user?.subscription?.type || 'free';\n};\n\n// Main rate limiting middleware\nexport const rateLimiter = async (\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> => {\n  try {\n    const clientId = getClientId(req);\n    const subscription = getUserSubscription(req);\n    \n    // Use premium rate limiter for premium users\n    const limiter = subscription === 'premium' || subscription === 'pro' \n      ? premiumRateLimiter \n      : rateLimiter;\n    \n    await limiter.consume(clientId);\n    \n    // Add rate limit headers\n    const resRateLimiter = await limiter.get(clientId);\n    if (resRateLimiter) {\n      res.set({\n        'X-RateLimit-Limit': String(limiter.points),\n        'X-RateLimit-Remaining': String(resRateLimiter.remainingPoints || 0),\n        'X-RateLimit-Reset': String(resRateLimiter.msBeforeNext || 0),\n      });\n    }\n    \n    next();\n  } catch (rejRes: any) {\n    const remainingPoints = rejRes?.remainingPoints || 0;\n    const msBeforeNext = rejRes?.msBeforeNext || 0;\n    const totalHits = rejRes?.totalHits || 0;\n    \n    // Set rate limit headers\n    res.set({\n      'X-RateLimit-Limit': String(rateLimiter.points),\n      'X-RateLimit-Remaining': String(remainingPoints),\n      'X-RateLimit-Reset': String(msBeforeNext),\n      'Retry-After': String(Math.round(msBeforeNext / 1000)),\n    });\n    \n    logger.warn('Rate limit exceeded:', {\n      clientId: getClientId(req),\n      path: req.originalUrl,\n      method: req.method,\n      totalHits,\n      remainingPoints,\n      msBeforeNext,\n    });\n    \n    res.status(HTTP_STATUS_CODES.TOO_MANY_REQUESTS).json({\n      success: false,\n      message: 'Too many requests, please try again later.',\n      code: 'RATE_LIMIT_EXCEEDED',\n      retryAfter: Math.round(msBeforeNext / 1000),\n      details: {\n        limit: rateLimiter.points,\n        remaining: remainingPoints,\n        resetTime: new Date(Date.now() + msBeforeNext).toISOString(),\n      },\n    });\n  }\n};\n\n// Authentication endpoint rate limiting\nexport const authRateLimit = async (\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> => {\n  try {\n    const ip = req.ip || req.connection.remoteAddress || 'unknown';\n    const key = `auth:${ip}`;\n    \n    await authRateLimiter.consume(key);\n    next();\n  } catch (rejRes: any) {\n    const msBeforeNext = rejRes?.msBeforeNext || 0;\n    \n    logger.warn('Auth rate limit exceeded:', {\n      ip: req.ip,\n      path: req.originalUrl,\n      method: req.method,\n    });\n    \n    res.status(HTTP_STATUS_CODES.TOO_MANY_REQUESTS).json({\n      success: false,\n      message: 'Too many authentication attempts, please try again later.',\n      code: 'AUTH_RATE_LIMIT_EXCEEDED',\n      retryAfter: Math.round(msBeforeNext / 1000),\n    });\n  }\n};\n\n// API endpoint rate limiting (for internal API calls)\nexport const apiRateLimit = async (\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> => {\n  try {\n    const clientId = getClientId(req);\n    const key = `api:${clientId}`;\n    \n    await apiRateLimiter.consume(key);\n    next();\n  } catch (rejRes: any) {\n    const msBeforeNext = rejRes?.msBeforeNext || 0;\n    \n    logger.warn('API rate limit exceeded:', {\n      clientId: getClientId(req),\n      path: req.originalUrl,\n      method: req.method,\n    });\n    \n    res.status(HTTP_STATUS_CODES.TOO_MANY_REQUESTS).json({\n      success: false,\n      message: 'API rate limit exceeded, please try again later.',\n      code: 'API_RATE_LIMIT_EXCEEDED',\n      retryAfter: Math.round(msBeforeNext / 1000),\n    });\n  }\n};\n\n// Rate limiting for external API calls (internal use)\nexport const checkExternalApiRateLimit = async (service: string, operation: string): Promise<boolean> => {\n  try {\n    const key = `external:${service}:${operation}`;\n    await apiRateLimiter.consume(key);\n    return true;\n  } catch (rejRes) {\n    logger.warn('External API rate limit exceeded:', {\n      service,\n      operation,\n      msBeforeNext: rejRes?.msBeforeNext || 0,\n    });\n    return false;\n  }\n};\n\n// Reset rate limit for a specific key (admin use)\nexport const resetRateLimit = async (key: string): Promise<void> => {\n  try {\n    await rateLimiter.delete(key);\n    logger.info('Rate limit reset for key:', key);\n  } catch (error) {\n    logger.error('Failed to reset rate limit:', error);\n    throw error;\n  }\n};\n\n// Get rate limit status for a key\nexport const getRateLimitStatus = async (key: string): Promise<any> => {\n  try {\n    return await rateLimiter.get(key);\n  } catch (error) {\n    logger.error('Failed to get rate limit status:', error);\n    return null;\n  }\n};\n\n// Progressive rate limiting based on user behavior\nexport const adaptiveRateLimit = (basePoints: number, factor: number = 1.5) => {\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      const clientId = getClientId(req);\n      const userBehavior = await getUserBehaviorScore(clientId);\n      \n      // Adjust rate limit based on user behavior\n      const adjustedPoints = Math.floor(basePoints * (userBehavior.trustScore || 1));\n      \n      const dynamicLimiter = new RateLimiterMemory({\n        keyPrefix: 'rl:adaptive',\n        points: adjustedPoints,\n        duration: WINDOW_SIZE_IN_MINUTES * 60,\n        blockDuration: WINDOW_SIZE_IN_MINUTES * 60,\n      });\n      \n      await dynamicLimiter.consume(clientId);\n      next();\n    } catch (rejRes: any) {\n      const msBeforeNext = rejRes?.msBeforeNext || 0;\n      \n      res.status(HTTP_STATUS_CODES.TOO_MANY_REQUESTS).json({\n        success: false,\n        message: 'Adaptive rate limit exceeded.',\n        code: 'ADAPTIVE_RATE_LIMIT_EXCEEDED',\n        retryAfter: Math.round(msBeforeNext / 1000),\n      });\n    }\n  };\n};\n\n// Helper function to get user behavior score\nconst getUserBehaviorScore = async (clientId: string): Promise<{ trustScore: number }> => {\n  // This would integrate with a user behavior analytics system\n  // For now, return a default score\n  return { trustScore: 1.0 };\n};\n\nexport default {\n  rateLimiter,\n  authRateLimit,\n  apiRateLimit,\n  checkExternalApiRateLimit,\n  resetRateLimit,\n  getRateLimitStatus,\n  adaptiveRateLimit,\n};"