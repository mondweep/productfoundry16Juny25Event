import { Request, Response, NextFunction } from 'express';\nimport { logger } from '../utils/logger';\nimport { HTTP_STATUS_CODES, ERROR_MESSAGES } from '../config/constants';\nimport { ValidationError } from 'joi';\nimport mongoose from 'mongoose';\n\n// Custom error class\nexport class AppError extends Error {\n  public statusCode: number;\n  public isOperational: boolean;\n  public code?: string;\n  public details?: any;\n\n  constructor(\n    message: string,\n    statusCode: number = HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR,\n    isOperational: boolean = true,\n    code?: string,\n    details?: any\n  ) {\n    super(message);\n    this.statusCode = statusCode;\n    this.isOperational = isOperational;\n    this.code = code;\n    this.details = details;\n\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n// Error response interface\ninterface ErrorResponse {\n  success: false;\n  message: string;\n  code?: string;\n  details?: any;\n  stack?: string;\n  timestamp: string;\n  path: string;\n  method: string;\n}\n\n// Handle different types of errors\nconst handleCastErrorDB = (err: mongoose.Error.CastError): AppError => {\n  const message = `Invalid ${err.path}: ${err.value}`;\n  return new AppError(message, HTTP_STATUS_CODES.BAD_REQUEST, true, 'INVALID_DATA');\n};\n\nconst handleDuplicateFieldsDB = (err: any): AppError => {\n  const value = err.errmsg?.match(/([\"])(\\\\?.)*?\\1/)?.[0];\n  const message = `Duplicate field value: ${value}. Please use another value!`;\n  return new AppError(message, HTTP_STATUS_CODES.CONFLICT, true, 'DUPLICATE_FIELD');\n};\n\nconst handleValidationErrorDB = (err: mongoose.Error.ValidationError): AppError => {\n  const errors = Object.values(err.errors).map(el => el.message);\n  const message = `Invalid input data. ${errors.join('. ')}`;\n  return new AppError(message, HTTP_STATUS_CODES.UNPROCESSABLE_ENTITY, true, 'VALIDATION_ERROR');\n};\n\nconst handleJWTError = (): AppError =>\n  new AppError('Invalid token. Please log in again!', HTTP_STATUS_CODES.UNAUTHORIZED, true, 'INVALID_TOKEN');\n\nconst handleJWTExpiredError = (): AppError =>\n  new AppError('Your token has expired! Please log in again.', HTTP_STATUS_CODES.UNAUTHORIZED, true, 'TOKEN_EXPIRED');\n\nconst handleJoiValidationError = (err: ValidationError): AppError => {\n  const message = err.details.map(detail => detail.message).join(', ');\n  return new AppError(message, HTTP_STATUS_CODES.BAD_REQUEST, true, 'VALIDATION_ERROR', err.details);\n};\n\nconst handleRateLimitError = (): AppError =>\n  new AppError('Too many requests, please try again later.', HTTP_STATUS_CODES.TOO_MANY_REQUESTS, true, 'RATE_LIMIT_EXCEEDED');\n\n// Send error response\nconst sendErrorDev = (err: AppError, req: Request, res: Response): void => {\n  const errorResponse: ErrorResponse = {\n    success: false,\n    message: err.message,\n    code: err.code,\n    details: err.details,\n    stack: err.stack,\n    timestamp: new Date().toISOString(),\n    path: req.originalUrl,\n    method: req.method,\n  };\n\n  logger.error('Error in development mode:', {\n    error: err.message,\n    stack: err.stack,\n    path: req.originalUrl,\n    method: req.method,\n    statusCode: err.statusCode,\n    user: (req as any).userId,\n  });\n\n  res.status(err.statusCode).json(errorResponse);\n};\n\nconst sendErrorProd = (err: AppError, req: Request, res: Response): void => {\n  // Operational, trusted error: send message to client\n  if (err.isOperational) {\n    const errorResponse: ErrorResponse = {\n      success: false,\n      message: err.message,\n      code: err.code,\n      timestamp: new Date().toISOString(),\n      path: req.originalUrl,\n      method: req.method,\n    };\n\n    // Include details for validation errors\n    if (err.code === 'VALIDATION_ERROR' && err.details) {\n      errorResponse.details = err.details;\n    }\n\n    res.status(err.statusCode).json(errorResponse);\n  } else {\n    // Programming or other unknown error: don't leak error details\n    logger.error('Unexpected error in production:', {\n      error: err.message,\n      stack: err.stack,\n      path: req.originalUrl,\n      method: req.method,\n      statusCode: err.statusCode,\n      user: (req as any).userId,\n    });\n\n    res.status(HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR).json({\n      success: false,\n      message: ERROR_MESSAGES.INTERNAL_ERROR,\n      code: 'INTERNAL_ERROR',\n      timestamp: new Date().toISOString(),\n      path: req.originalUrl,\n      method: req.method,\n    });\n  }\n};\n\n// Main error handling middleware\nexport const errorHandler = (\n  err: any,\n  req: Request,\n  res: Response,\n  next: NextFunction\n): void => {\n  let error = { ...err };\n  error.message = err.message;\n\n  // Log error for monitoring\n  logger.error('Global error handler:', {\n    error: err.message,\n    stack: err.stack,\n    path: req.originalUrl,\n    method: req.method,\n    user: (req as any).userId,\n    timestamp: new Date().toISOString(),\n  });\n\n  // Mongoose bad ObjectId\n  if (err.name === 'CastError') {\n    error = handleCastErrorDB(err);\n  }\n\n  // Mongoose duplicate key\n  if (err.code === 11000) {\n    error = handleDuplicateFieldsDB(err);\n  }\n\n  // Mongoose validation error\n  if (err.name === 'ValidationError') {\n    error = handleValidationErrorDB(err);\n  }\n\n  // JWT errors\n  if (err.name === 'JsonWebTokenError') {\n    error = handleJWTError();\n  }\n  if (err.name === 'TokenExpiredError') {\n    error = handleJWTExpiredError();\n  }\n\n  // Joi validation errors\n  if (err.isJoi || err.name === 'ValidationError' && err.details) {\n    error = handleJoiValidationError(err);\n  }\n\n  // Rate limiting errors\n  if (err.name === 'TooManyRequestsError') {\n    error = handleRateLimitError();\n  }\n\n  // Ensure error has proper structure\n  if (!(error instanceof AppError)) {\n    error = new AppError(\n      error.message || ERROR_MESSAGES.INTERNAL_ERROR,\n      error.statusCode || HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR,\n      error.isOperational || false,\n      error.code || 'INTERNAL_ERROR'\n    );\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    sendErrorDev(error, req, res);\n  } else {\n    sendErrorProd(error, req, res);\n  }\n};\n\n// 404 handler\nexport const notFoundHandler = (req: Request, res: Response, next: NextFunction): void => {\n  const error = new AppError(\n    `Route ${req.originalUrl} not found`,\n    HTTP_STATUS_CODES.NOT_FOUND,\n    true,\n    'ROUTE_NOT_FOUND'\n  );\n  next(error);\n};\n\n// Async error handler wrapper\nexport const catchAsync = (fn: Function) => {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n};\n\n// Validation error helper\nexport const createValidationError = (message: string, details?: any): AppError => {\n  return new AppError(message, HTTP_STATUS_CODES.BAD_REQUEST, true, 'VALIDATION_ERROR', details);\n};\n\n// Not found error helper\nexport const createNotFoundError = (resource: string): AppError => {\n  return new AppError(`${resource} not found`, HTTP_STATUS_CODES.NOT_FOUND, true, 'NOT_FOUND');\n};\n\n// Forbidden error helper\nexport const createForbiddenError = (message: string = ERROR_MESSAGES.FORBIDDEN): AppError => {\n  return new AppError(message, HTTP_STATUS_CODES.FORBIDDEN, true, 'FORBIDDEN');\n};\n\n// Unauthorized error helper\nexport const createUnauthorizedError = (message: string = ERROR_MESSAGES.UNAUTHORIZED): AppError => {\n  return new AppError(message, HTTP_STATUS_CODES.UNAUTHORIZED, true, 'UNAUTHORIZED');\n};\n\n// Conflict error helper\nexport const createConflictError = (message: string): AppError => {\n  return new AppError(message, HTTP_STATUS_CODES.CONFLICT, true, 'CONFLICT');\n};\n\nexport default {\n  AppError,\n  errorHandler,\n  notFoundHandler,\n  catchAsync,\n  createValidationError,\n  createNotFoundError,\n  createForbiddenError,\n  createUnauthorizedError,\n  createConflictError,\n};"