import { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\nimport { User, IUser } from '../models/User';\nimport { logger } from '../utils/logger';\nimport { HTTP_STATUS_CODES, ERROR_MESSAGES } from '../config/constants';\n\n// Extend Request interface to include user\nexport interface AuthenticatedRequest extends Request {\n  user?: IUser;\n  userId?: string;\n}\n\n// JWT payload interface\ninterface JWTPayload {\n  userId: string;\n  email: string;\n  role: string;\n  iat: number;\n  exp: number;\n}\n\n// Auth middleware\nexport const authMiddleware = async (\n  req: AuthenticatedRequest,\n  res: Response,\n  next: NextFunction\n): Promise<void> => {\n  try {\n    // Get token from header\n    const authHeader = req.headers.authorization;\n    const token = authHeader && authHeader.startsWith('Bearer ') \n      ? authHeader.substring(7) \n      : null;\n\n    if (!token) {\n      res.status(HTTP_STATUS_CODES.UNAUTHORIZED).json({\n        success: false,\n        message: ERROR_MESSAGES.UNAUTHORIZED,\n        code: 'TOKEN_MISSING'\n      });\n      return;\n    }\n\n    // Verify token\n    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;\n    \n    // Find user\n    const user = await User.findById(decoded.userId).select('-password -refreshTokens');\n    \n    if (!user) {\n      res.status(HTTP_STATUS_CODES.UNAUTHORIZED).json({\n        success: false,\n        message: 'User not found',\n        code: 'USER_NOT_FOUND'\n      });\n      return;\n    }\n\n    if (!user.isActive) {\n      res.status(HTTP_STATUS_CODES.UNAUTHORIZED).json({\n        success: false,\n        message: 'Account is deactivated',\n        code: 'ACCOUNT_DEACTIVATED'\n      });\n      return;\n    }\n\n    // Attach user to request\n    req.user = user;\n    req.userId = user._id.toString();\n    \n    next();\n  } catch (error) {\n    if (error instanceof jwt.TokenExpiredError) {\n      res.status(HTTP_STATUS_CODES.UNAUTHORIZED).json({\n        success: false,\n        message: 'Token expired',\n        code: 'TOKEN_EXPIRED'\n      });\n    } else if (error instanceof jwt.JsonWebTokenError) {\n      res.status(HTTP_STATUS_CODES.UNAUTHORIZED).json({\n        success: false,\n        message: 'Invalid token',\n        code: 'TOKEN_INVALID'\n      });\n    } else {\n      logger.error('Auth middleware error:', error);\n      res.status(HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR).json({\n        success: false,\n        message: ERROR_MESSAGES.INTERNAL_ERROR,\n        code: 'AUTH_ERROR'\n      });\n    }\n  }\n};\n\n// Optional auth middleware (doesn't require authentication)\nexport const optionalAuthMiddleware = async (\n  req: AuthenticatedRequest,\n  res: Response,\n  next: NextFunction\n): Promise<void> => {\n  try {\n    const authHeader = req.headers.authorization;\n    const token = authHeader && authHeader.startsWith('Bearer ') \n      ? authHeader.substring(7) \n      : null;\n\n    if (token) {\n      try {\n        const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;\n        const user = await User.findById(decoded.userId).select('-password -refreshTokens');\n        \n        if (user && user.isActive) {\n          req.user = user;\n          req.userId = user._id.toString();\n        }\n      } catch (error) {\n        // Silently ignore invalid tokens in optional auth\n        logger.debug('Optional auth token validation failed:', error);\n      }\n    }\n\n    next();\n  } catch (error) {\n    logger.error('Optional auth middleware error:', error);\n    next(); // Continue without authentication\n  }\n};\n\n// Role-based authorization middleware\nexport const requireRole = (roles: string | string[]) => {\n  const allowedRoles = Array.isArray(roles) ? roles : [roles];\n  \n  return (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {\n    if (!req.user) {\n      res.status(HTTP_STATUS_CODES.UNAUTHORIZED).json({\n        success: false,\n        message: ERROR_MESSAGES.UNAUTHORIZED,\n        code: 'AUTHENTICATION_REQUIRED'\n      });\n      return;\n    }\n\n    if (!allowedRoles.includes(req.user.role)) {\n      res.status(HTTP_STATUS_CODES.FORBIDDEN).json({\n        success: false,\n        message: ERROR_MESSAGES.FORBIDDEN,\n        code: 'INSUFFICIENT_PERMISSIONS',\n        required: allowedRoles,\n        current: req.user.role\n      });\n      return;\n    }\n\n    next();\n  };\n};\n\n// Subscription-based authorization middleware\nexport const requireSubscription = (subscriptionTypes: string | string[]) => {\n  const allowedTypes = Array.isArray(subscriptionTypes) ? subscriptionTypes : [subscriptionTypes];\n  \n  return (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {\n    if (!req.user) {\n      res.status(HTTP_STATUS_CODES.UNAUTHORIZED).json({\n        success: false,\n        message: ERROR_MESSAGES.UNAUTHORIZED,\n        code: 'AUTHENTICATION_REQUIRED'\n      });\n      return;\n    }\n\n    const userSubscription = req.user.subscription?.type || 'free';\n    \n    if (!allowedTypes.includes(userSubscription)) {\n      res.status(HTTP_STATUS_CODES.FORBIDDEN).json({\n        success: false,\n        message: 'Subscription upgrade required',\n        code: 'SUBSCRIPTION_REQUIRED',\n        required: allowedTypes,\n        current: userSubscription\n      });\n      return;\n    }\n\n    // Check if subscription is still active (for paid subscriptions)\n    if (userSubscription !== 'free' && req.user.subscription?.endDate) {\n      if (new Date() > req.user.subscription.endDate) {\n        res.status(HTTP_STATUS_CODES.FORBIDDEN).json({\n          success: false,\n          message: 'Subscription expired',\n          code: 'SUBSCRIPTION_EXPIRED',\n          expiredAt: req.user.subscription.endDate\n        });\n        return;\n      }\n    }\n\n    next();\n  };\n};\n\n// Self or admin access middleware\nexport const requireSelfOrAdmin = (userIdParam: string = 'userId') => {\n  return (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {\n    if (!req.user) {\n      res.status(HTTP_STATUS_CODES.UNAUTHORIZED).json({\n        success: false,\n        message: ERROR_MESSAGES.UNAUTHORIZED,\n        code: 'AUTHENTICATION_REQUIRED'\n      });\n      return;\n    }\n\n    const targetUserId = req.params[userIdParam];\n    const isOwner = req.user._id.toString() === targetUserId;\n    const isAdmin = req.user.role === 'admin';\n\n    if (!isOwner && !isAdmin) {\n      res.status(HTTP_STATUS_CODES.FORBIDDEN).json({\n        success: false,\n        message: ERROR_MESSAGES.FORBIDDEN,\n        code: 'ACCESS_DENIED'\n      });\n      return;\n    }\n\n    next();\n  };\n};\n\n// Refresh token middleware\nexport const refreshTokenMiddleware = async (\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> => {\n  try {\n    const { refreshToken } = req.body;\n\n    if (!refreshToken) {\n      res.status(HTTP_STATUS_CODES.BAD_REQUEST).json({\n        success: false,\n        message: 'Refresh token required',\n        code: 'REFRESH_TOKEN_MISSING'\n      });\n      return;\n    }\n\n    // Verify refresh token\n    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET!) as any;\n    \n    // Find user and check if refresh token exists and is active\n    const user = await User.findById(decoded.userId);\n    \n    if (!user) {\n      res.status(HTTP_STATUS_CODES.UNAUTHORIZED).json({\n        success: false,\n        message: 'User not found',\n        code: 'USER_NOT_FOUND'\n      });\n      return;\n    }\n\n    const tokenRecord = user.refreshTokens.find(\n      token => token.token === refreshToken && token.isActive && token.expiresAt > new Date()\n    );\n\n    if (!tokenRecord) {\n      res.status(HTTP_STATUS_CODES.UNAUTHORIZED).json({\n        success: false,\n        message: 'Invalid or expired refresh token',\n        code: 'REFRESH_TOKEN_INVALID'\n      });\n      return;\n    }\n\n    // Generate new tokens\n    const tokens = await user.generateAuthTokens();\n    \n    // Deactivate old refresh token\n    tokenRecord.isActive = false;\n    await user.save();\n\n    res.json({\n      success: true,\n      message: 'Tokens refreshed successfully',\n      data: {\n        accessToken: tokens.accessToken,\n        refreshToken: tokens.refreshToken,\n        user: {\n          id: user._id,\n          email: user.email,\n          firstName: user.firstName,\n          lastName: user.lastName,\n          role: user.role\n        }\n      }\n    });\n  } catch (error) {\n    logger.error('Refresh token middleware error:', error);\n    res.status(HTTP_STATUS_CODES.UNAUTHORIZED).json({\n      success: false,\n      message: 'Invalid refresh token',\n      code: 'REFRESH_TOKEN_ERROR'\n    });\n  }\n};\n\nexport default {\n  authMiddleware,\n  optionalAuthMiddleware,\n  requireRole,\n  requireSubscription,\n  requireSelfOrAdmin,\n  refreshTokenMiddleware,\n};"